\chapter*{Introducción}\label{chapter:introduction}
\addcontentsline{toc}{chapter}{Introducción}

El análisis de similitud de código es un campo de gran escala en Ciencias de la Computación, especialmente en áreas como la detección de plagio, la revisión de código y la asistencia en programación. Este análisis permite comparar fragmentos de código para identificar similitudes y diferencias, proporcionando información valiosa para la refactorización, la mejora de la calidad del código y la promoción de buenas prácticas de programación. \\

\section*{Motivación}
La evolución y expansión del software en la actualidad han incrementado notablemente su complejidad y volumen, creando una demanda urgente por herramientas avanzadas que permitan un análisis y comprensión más profundos del código fuente. En este contexto, la métrica de similitud de código se vuelve crucial, ya que puede identificar duplicaciones, detectar plagio y reconocer patrones reutilizables. Esta capacidad no solo ayuda a mantener la integridad del software al prevenir el plagio, sino que también fomenta prácticas de desarrollo más eficientes y sostenibles al identificar oportunidades para la refactorización y la reutilización de código.

La detección de plagio es especialmente relevante en el ámbito académico y profesional, donde la originalidad del trabajo es fundamental. Las herramientas avanzadas de análisis de similitud permiten identificar fragmentos de código que han sido copiados, modificados mínimamente o reutilizados sin atribución adecuada. Esto es esencial para mantener la equidad en la evaluación académica y proteger la propiedad intelectual en el desarrollo de software.

Con el avance continuo de las técnicas de aprendizaje automático y el procesamiento del lenguaje natural, se han abierto nuevas posibilidades para llevar a cabo este análisis de manera más eficiente y precisa. Los algoritmos de machine learning pueden aprender a identificar similitudes y diferencias en el código con una precisión antes inalcanzable, mientras que las técnicas de procesamiento del lenguaje natural permiten una comprensión más profunda y contextual del contenido del código. Estas innovaciones no solo mejoran la capacidad de detectar similitudes y plagio, sino que también pueden ofrecer comprensiones profundas sobre la estructura y el diseño del software, facilitando una mejora continua y sistemática del desarrollo de software.

\section*{Problemática}
A pesar de los avances en el análisis de similitud de código, aún existen desafíos significativos. Las técnicas tradicionales, basadas en comparaciones textuales simples, son limitadas en su capacidad para capturar la estructura y semántica del código. Además, los enfoques más avanzados, como los basados en árboles de sintaxis abstracta (AST) y modelos de aprendizaje profundo, pueden ser computacionalmente costosos y difíciles de implementar a gran escala. En este proyecto se encontraron diferentes inconvenientes como la falta de datos y la falta de datos etiquetados, pues se utiliza un dataset creado con proyectos de programación de 1er año de la facultad,ademas la gramática utilizada por ANTLR no es la mas reciente, por tanto en algunos casos de proyectos donde se utiliza una sintaxis de C\# moderna existe problemas para generar el AST completo, como solución a esto se hicieron unas ligeras modificaciones a la gramática de C\#.

\section*{Objetivos Generales} 

\renewcommand{\labelenumi}{\Roman{enumi}.}
\begin{enumerate}
	\item Desarrollar un marco de análisis de similitud de código que combine la extracción de características mediante árboles de sintaxis abstracta (AST) con técnicas avanzadas de aprendizaje automático para mejorar la precisión y eficiencia en la detección de similitudes.
	\item Contribuir al conocimiento académico y práctico en el campo del análisis de código, proporcionando herramientas y metodologías que puedan ser utilizadas tanto en entornos educativos como profesionales.
\end{enumerate}
 
\section*{Objetivos Específicos}

\renewcommand{\labelenumi}{\Roman{enumi}.}
\begin{enumerate}
	\item {\bf Implementar y Evaluar Algoritmos de Comparación Basados en AST}\\
	El primer objetivo es diseñar e implementar algoritmos de comparación que utilicen Árboles de Sintaxis Abstracta (AST) para identificar similitudes en el código. Este proceso implica desarrollar un método detallado para extraer subárboles de los AST y compararlos, capturando similitudes estructurales en diferentes niveles de granularidad. La efectividad de estos algoritmos se evaluará en términos de precisión y tiempo de procesamiento, comparándolos con los métodos tradicionales de similitud de código. Esto permitirá determinar si los enfoques basados en AST ofrecen ventajas significativas en el análisis de similitud de código.
	
	\item {\bf Integrar Técnicas de Aprendizaje Automático para la Detección de Similitudes} \\
El segundo objetivo es integrar técnicas de aprendizaje automático para mejorar la detección de similitudes en el código. Esto implica entrenar modelos de aprendizaje supervisado y no supervisado utilizando un conjunto de datos conformado por proyectos de C\# de orimer año la facultad de Ciencias de la Computación. Estos modelos deberán capturar patrones complejos y relaciones estructurales en el código, proporcionando una visión más profunda y precisa de las similitudes. La implementación de estas técnicas permitirá comparar su desempeño con los métodos tradicionales, evaluando mejoras en precisión y eficiencia.

	\item {\bf Desarrollar y Validar una Herramienta Práctica} \\
El tercer objetivo es desarrollar una herramienta de software que implemente las técnicas avanzadas desarrolladas, facilitando su uso por desarrolladores y educadores. Esta herramienta deberá ser práctica y accesible, permitiendo su integración en entornos de desarrollo reales. La validación de la herramienta se llevará a cabo en escenarios prácticos, como la detección de plagio en tareas de programación. Esto no solo demostrará la efectividad de las técnicas implementadas, sino que también garantizará que la herramienta sea útil y relevante para los usuarios finales.


\end{enumerate}
