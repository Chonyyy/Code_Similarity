\chapter{Propuesta}\label{chapter:proposal}

La implementacion  de este trabajo esta dividida en dos partes fundamentales: Extraccion del AST y trabajo con machine learning.

- Extraccion del AST: En esta parte se utiliza la herramienta ANTLR de C# para crear el ast de los proyectos. Luego de este ast se extraen los features para su posterior uso.

- Trabajo con machine learning: Se utiliza el modelo ---------- para determinar la semejanza entre 2 proyectos.


\section{Extraccion del AST}

ANTLR (Another Tool for Language Recognition) es una poderosa herramienta que se utiliza para generar analizadores léxicos y sintácticos a partir de gramáticas definidas por el usuario. Es ampliamente utilizada en la compilación y el procesamiento de lenguajes, ya que permite transformar el código fuente en estructuras de datos que pueden ser fácilmente manipuladas. En este caso, ANTLR se emplea para extraer Árboles de Sintaxis Abstracta (AST) a partir del código fuente de programas escritos en C#. \\

Una vez que se ha generado el AST, se puede manipular y analizar utilizando las estructuras de datos proporcionadas por ANTLR. Por ejemplo, se pueden recorrer los nodos del árbol, extraer información específica o transformar el AST para diferentes propósitos, en este caso se utilizó el listener proporcionado por ANTLR para recorrer el árbol y extraer los featurues. \\

\section{Extraccion de features}

En el análisis de similitud de código y detección de patrones, es crucial extraer características relevantes que capturen la estructura y el comportamiento del código. Para este propósito, se implementó una clase denominada {\bf FeatureExtractorListener}, que extiende la funcionalidad de ANTLR para analizar el código fuente en C#. A continuación, se presenta una descripción detallada del proceso de extracción de características y la importancia de cada característica extraída. \\

Características Extraídas y su Importancia


\begin{enumerate}
	\item Estructura del AST:
    		\begin{itemize}
			\item {\bf total_nodes:} Número total de nodos en el AST.
			\item {\bf max_depth:} Profundidad máxima del AST.
		\end{itemize}
		
	 \item Declaraciones y Variables:
    \begin{itemize}
        \item {\bf variables:} Número de variables locales.
        \item {\bf constants:} Número de constantes declaradas.
        \item {\bf variable_names:} Conjunto de nombres de variables y sus tipos.
        \item {\bf number_of_tuples:} Número de variables de tipo tupla.
        \item {\bf lists:} Número de listas declaradas.
        \item {\bf dicts:} Número de diccionarios declarados.
    \end{itemize}
    Las variables y las constantes son fundamentales para entender el estado y el flujo de datos en el código. La variedad y el tipo de estructuras de datos utilizadas (tuplas, listas, diccionarios) también proporcionan información sobre el estilo de programación y la complejidad del código.

    \item Declaraciones de Métodos y Clases:
    \begin{itemize}
        \item {\bf methods:} Número de métodos declarados.
        \item {\bf method_names:} Conjunto de nombres de métodos.
        \item {\bf method_return_types:} Conjunto de tipos de retorno de métodos.
        \item {\bf method_parameters:} Lista de parámetros de métodos.
        \item {\bf classes:} Número de clases declaradas.
        \item {\bf class_names:} Conjunto de nombres de clases.
        \item {\bf abstract_classes:} Número de clases abstractas.
        \item {\bf sealed_classes:} Número de clases selladas.
        \item {\bf interfaces:} Número de interfaces declaradas.
        \item {\bf interface_names:} Conjunto de nombres de interfaces.
    \end{itemize}
    La estructura y los nombres de los métodos y clases proporcionan información sobre la organización y modularidad del código. Los métodos y sus parámetros son esenciales para entender la funcionalidad del código, mientras que las clases y sus tipos (abstractas, selladas) indican la arquitectura de la aplicación.

    \item Estructuras de Control:
    \begin{itemize}
        \item {\bf control_structures_if:} Número de sentencias if.
        \item {\bf control_structures_switch:} Número de sentencias switch.
        \item {\bf control_structures_for:} Número de bucles for.
        \item {\bf control_structures_while:} Número de bucles while.
        \item {\bf control_structures_dowhile:} Número de bucles do-while.
        \item {\bf try_catch_blocks:} Número de bloques try-catch.
    \end{itemize}
    Las estructuras de control son fundamentales para comprender el flujo del programa y su lógica. Un mayor número de estructuras de control indica una lógica más compleja y ramificada.

    \item Modificadores y Accesibilidad:
    \begin{itemize}
        \item {\bf access_modifiers_public:} Número de elementos públicos.
        \item {\bf access_modifiers_private:} Número de elementos privados.
        \item {\bf access_modifiers_protected:} Número de elementos protegidos.
        \item {\bf access_modifiers_internal:} Número de elementos internos.
        \item {\bf access_modifiers_static:} Número de elementos estáticos.
        \item {\bf access_modifiers_protected_internal:} Número de elementos protegidos internos.
        \item {\bf access_modifiers_private_protected:} Número de elementos privados protegidos.
    \end{itemize}
    Los modificadores de acceso proporcionan información sobre la encapsulación y visibilidad de los componentes del código. La prevalencia de ciertos modificadores puede indicar prácticas de diseño y seguridad en el código.

    \item Modificadores Específicos:
    \begin{itemize}
        \item {\bf modifier_readonly:} Número de elementos readonly.
        \item {\bf modifier_volatile:} Número de elementos volatile.
        \item {\bf modifier_virtual:} Número de elementos virtual.
        \item {\bf modifier_override:} Número de elementos override.
        \item {\bf modifier_new:} Número de elementos new.
        \item {\bf modifier_partial:} Número de elementos partial.
        \item {\bf modifier_extern:} Número de elementos extern.
        \item {\bf modifier_unsafe:} Número de elementos unsafe.
        \item {\bf modifier_async:} Número de elementos async.
    \end{itemize}
    Estos modificadores específicos indican características avanzadas y patrones de diseño en el código, como la concurrencia (async), la seguridad (unsafe) y la herencia (override, virtual).

    \item Llamadas a Librerías y LINQ:
    \begin{itemize}
        \item {\bf library_call_console:} Número de llamadas a la librería Console.
        \item {\bf library_call_math:} Número de llamadas a la librería Math.
        \item {\bf linq_queries_select:} Número de consultas LINQ Select.
        \item {\bf linq_queries_where:} Número de consultas LINQ Where.
        \item {\bf linq_queries_orderBy:} Número de consultas LINQ OrderBy.
        \item {\bf linq_queries_groupBy:} Número de consultas LINQ GroupBy.
        \item {\bf linq_queries_join:} Número de consultas LINQ Join.
        \item {\bf linq_queries_sum:} Número de consultas LINQ Sum.
        \item {\bf linq_queries_count:} Número de consultas LINQ Count.
    \end{itemize}
    Las llamadas a librerías y consultas LINQ proporcionan información sobre el uso de funcionalidades estándar y el manejo de colecciones de datos en el código.

    \item Otras Características:
    \begin{itemize}
        \item {\bf number_of_lambdas:} Número de expresiones lambda.
        \item {\bf number_of_getters:} Número de métodos get.
        \item {\bf number_of_setters:} Número de métodos set.
        \item {\bf number_of_namespaces:} Número de espacios de nombres.
        \item {\bf enums:} Número de enumeraciones.
        \item {\bf enum_names:} Conjunto de nombres de enumeraciones.
        \item {\bf delegates:} Número de delegados.
        \item {\bf delegate_names:} Conjunto de nombres de delegados.
        \item {\bf node_count:} Conteo de nodos por tipo.
    \end{itemize}
    Estas características adicionales proporcionan una visión más completa de las capacidades del código, su organización y las prácticas de programación utilizadas.

 
\end{enumerate}
    
        
La extracción de características con FeatureExtractorListener permite capturar una amplia gama de aspectos del código fuente en C#, desde su estructura y complejidad hasta los patrones de diseño y las prácticas de programación. Esta información es crucial para tareas como la detección de similitudes de código, la evaluación de la calidad del código y la identificación de posibles plagios. La implementación y el análisis detallado de estas características proporcionan una base sólida para mejorar la precisión y efectividad de las herramientas de análisis de código.

\section{Preparacion del dataset}


