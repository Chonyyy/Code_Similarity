\chapter{Modificaciones a la Gramática de ANTLR para Soporte de C\# Actual}\label{chapter:proposal}

ANTLR (Another Tool for Language Recognition) cuenta con una gramática basada en C\# 6.0, esta gramática presentaba limitaciones significativas al trabajar con el código moderno. Generaba errores durante el análisis sintáctico y resultaba en un árbol de sintaxis abstracta (AST) incompleto. Sin embargo, se decidió actualizar a una versión más actual de C\# 12.0 (introducida en noviembre de 2023), para reflejar las características introducidas en versiones posteriores.  A continuación, se describen los principales problemas encontrados y las modificaciones realizadas para solventarlos.\\

\section{C\# 7.0}

\subsection*{Variables \texttt{out}}
\textbf{Problema:} El uso de variables \texttt{out} requería una declaración previa. Desde C\# 7.0, se permite declarar variables directamente en la declaración del método.

\textbf{Solución:} Se modificó la regla \texttt{argument} para incluir una declaración de variable opcional antes del modificador \texttt{out}. Además, se ajustó la regla \texttt{local\_variable\_declaration} para permitir el uso de \texttt{out} como modificador de variable.

\subsection*{Tuplas y Deconstrucción}
\textbf{Problema:} Las tuplas no eran un tipo nativo y requerían una biblioteca externa. Desde C\# 7.0, se introdujeron tuplas como un tipo nativo, permitiendo la deconstrucción de sus elementos.

\textbf{Solución:} Se agregó una nueva regla \texttt{tuple\_type} para definir tipos de tuplas. Se modificó la regla \texttt{type} para incluir \texttt{tuple\_type}. Además, se añadió una regla \texttt{tuple\_literal} para la creación de tuplas y se actualizó la regla \texttt{assignment} para soportar la deconstrucción de tuplas.

\subsection*{Coincidencia de Patrones}
\textbf{Problema:} No había soporte para coincidencia de patrones en C\#. Desde C\# 7.0, se introdujo la coincidencia de patrones que permite simplificar el código al verificar tipos y valores.

\textbf{Solución:} Se introdujo una nueva regla \texttt{pattern\_matching\_expression} que incluye subreglas para diferentes tipos de patrones (constante, tipo, var). Se actualizaron las reglas \texttt{is\_expression} y \texttt{switch\_section} para incorporar la nueva sintaxis de coincidencia de patrones.

\subsection*{Funciones Locales}
\textbf{Problema:} Las funciones debían estar definidas a nivel de clase. Desde C\# 7.0, se introdujeron funciones locales que permiten definir funciones dentro de métodos.

\textbf{Solución:} Se creó una nueva regla \texttt{local\_function\_declaration} similar a \texttt{method\_declaration}, pero permitida dentro de bloques de código. Se actualizó la regla \texttt{statement} para incluir \texttt{local\_function\_declaration} como una opción válida.

\subsection*{Miembros Expresados con Cuerpo de Expresión Expandido}
\textbf{Problema:} Los miembros debían tener un cuerpo completo. Desde C\# 7.0, se introdujo la posibilidad de usar cuerpos de expresión para simplificar la definición de miembros.

\textbf{Solución:} Se modificaron las reglas \texttt{method\_declaration}, \texttt{property\_declaration}, \texttt{operator\_declaration}, \texttt{constructor\_declaration}, \texttt{destructor\_declaration}, y \texttt{indexer\_declaration} para permitir el uso de \texttt{=>} seguido de una expresión como alternativa al cuerpo del bloque tradicional.

\subsection*{Locales \texttt{ref}}
\textbf{Problema:} No era posible utilizar locales \texttt{ref} que permiten referenciar variables directamente en lugar de copiar su valor. Desde C\# 7.0, se introdujeron los locales \texttt{ref}.

\textbf{Solución:} Se actualizó la regla \texttt{local\_variable\_declaration} para incluir el modificador \texttt{ref} opcional. Se agregó una nueva regla \texttt{ref\_expression} para manejar expresiones que devuelven referencias.

\subsection*{Retornos \texttt{ref}}
\textbf{Problema:} Los métodos no podían devolver referencias directamente. Desde C\# 7.0, se introdujo el soporte para retornos \texttt{ref}, permitiendo que un método devuelva una referencia a un valor existente.

\textbf{Solución:} Se modificó la regla \texttt{method\_declaration} para permitir el modificador \texttt{ref} antes del tipo de retorno. Se actualizó la regla \texttt{return\_statement} para incluir la opción de devolver una referencia usando \texttt{ref}.

\subsection*{Discards}
\textbf{Problema:} No había una forma explícita de ignorar valores en asignaciones o expresiones. Desde C\# 7.0, se introdujo el uso de discards (\texttt{\_}) que permite omitir valores que no son necesarios.

\textbf{Solución:} Se agregó una nueva regla \texttt{discard} que reconoce el símbolo \texttt{\_}. Se actualizaron las reglas relevantes como \texttt{variable\_declaration}, \texttt{foreach\_statement}, y \texttt{out\_variable\_declaration} para permitir el uso de \texttt{discard} en lugar de identificadores.

\subsection*{Literales Binarios y Separadores de Dígitos}
\textbf{Problema:} No había soporte para literales binarios ni separadores de dígitos en números. Desde C\# 7.0, se introdujeron literales binarios y la capacidad de usar guiones bajos como separadores en literales numéricos.

\textbf{Solución:} Se modificó la regla \texttt{integer\_literal} para incluir el prefijo \texttt{0b} o \texttt{0B} para literales binarios. Se actualizaron las reglas de literales numéricos para permitir guiones bajos (\texttt{\_}) entre dígitos en cualquier posición excepto al principio o final del literal.

\subsection*{Expresiones \texttt{throw}}
\textbf{Problema:} Las expresiones \texttt{throw} solo podían usarse en instrucciones completas. Desde C\# 7.0, se introdujeron expresiones \texttt{throw}, permitiendo lanzar excepciones como parte de expresiones más complejas.

\textbf{Solución:} Se creó una nueva regla \texttt{throw\_expression} que permite el uso de \texttt{throw} seguido de una expresión. Se actualizaron las reglas relevantes como \texttt{conditional\_expression} y \texttt{null\_coalescing\_expression} para incluir \texttt{throw\_expression} como una opción válida.


\subsection{C\# 7.1}

\subsection*{Método \texttt{Main} Asíncrono}
\textbf{Problema:} El método de entrada \texttt{Main} no podía ser asíncrono. Esto limitaba el uso de operaciones asincrónicas en la inicialización de aplicaciones. Desde C\# 7.1, se permite que el método \texttt{Main} tenga el modificador \texttt{async}.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el modificador \texttt{async} en el método de entrada \texttt{Main}.

\subsection*{Expresiones Literales por Defecto (\texttt{default})}
\textbf{Problema:} En versiones anteriores, era necesario especificar explícitamente el tipo al usar valores predeterminados. Desde C\# 7.1, se introdujeron las expresiones literales \texttt{default}, que infieren automáticamente el tipo cuando es posible.

\textbf{Solución:} Se modificó la gramática para permitir expresiones literales \texttt{default} en contextos donde el tipo puede inferirse.

\subsection*{Inferencia de Nombres de Elementos en Tuplas}
\textbf{Problema:} En versiones anteriores, era necesario nombrar explícitamente los elementos de una tupla al inicializarla. Desde C\# 7.1, se permite inferir los nombres de los elementos a partir de las variables utilizadas en la inicialización.

\textbf{Solución:} Se ajustaron las reglas gramaticales para inferir automáticamente los nombres de los elementos en inicializaciones de tuplas.

\subsection*{Coincidencia de Patrones en Parámetros Genéricos}
\textbf{Problema:} No era posible realizar coincidencia de patrones en variables cuyo tipo era un parámetro genérico. Desde C\# 7.1, se permite realizar coincidencias de patrones en este caso.

\textbf{Solución:} Se expandieron las reglas para permitir coincidencia de patrones en variables con tipos genéricos.


\subsection{C\# 7.2}

\subsection*{Inicializadores en Arreglos Stackalloc}
\textbf{Problema:} No era posible inicializar directamente los arreglos creados con \texttt{stackalloc}. Desde C\# 7.2, se permite usar inicializadores en arreglos \texttt{stackalloc}.

\textbf{Solución:} Se ajustó la gramática para permitir inicializadores en arreglos creados con \texttt{stackalloc}.

\subsection*{Uso de Sentencias Fijas con Tipos que Soportan Patrones}
\textbf{Problema:} Las sentencias \texttt{fixed} solo podían usarse con tipos específicos como arreglos o cadenas. Desde C\# 7.2, se permite usar sentencias \texttt{fixed} con cualquier tipo que soporte un patrón.

\textbf{Solución:} Se modificó la regla \texttt{fixed\_statement} para permitir el uso de cualquier tipo que soporte patrones.

\subsection*{Acceso a Campos Fijos Sin Fijación}
\textbf{Problema:} Para acceder a campos fijos era necesario fijar la dirección de memoria explícitamente. Desde C\# 7.2, se permite acceder a campos fijos sin necesidad de fijarlos.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el acceso a campos fijos sin fijación explícita.

\subsection*{Reasignación de Variables Locales Referenciadas}
\textbf{Problema:} No era posible reasignar variables locales referenciadas (\texttt{ref}). Desde C\# 7.2, se permite reasignar estas variables.

\textbf{Solución:} Se modificaron las reglas para permitir la reasignación de variables locales referenciadas.

\subsection*{Declaración de Tipos Struct Solo de Lectura (\texttt{readonly struct})}
\textbf{Problema:} No había una forma explícita de declarar estructuras inmutables. Desde C\# 7.2, se introdujo el modificador \texttt{readonly struct} para indicar que una estructura es inmutable y debe pasarse como un parámetro \texttt{in}.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{readonly} en la declaración de estructuras.

\subsection*{Modificador \texttt{in} en Parámetros}
\textbf{Problema:} No era posible pasar argumentos por referencia sin permitir su modificación. Desde C\# 7.2, se introdujo el modificador \texttt{in}, que permite pasar argumentos por referencia sin permitir modificaciones.

\textbf{Solución:} Se ajustó la regla \texttt{parameter\_modifier} para incluir el modificador \texttt{in}.

\subsection*{Modificador \texttt{ref readonly} en Retornos de Métodos}
\textbf{Problema:} No había una forma explícita de devolver referencias inmutables desde métodos. Desde C\# 7.2, se introdujo el modificador \texttt{ref readonly}, que permite devolver referencias inmutables.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{ref readonly} en las reglas de retorno de métodos.

\subsection*{Declaración de Tipos Struct Referenciados (\texttt{ref struct})}
\textbf{Problema:} No había una forma explícita de declarar estructuras que accedan directamente a memoria administrada y deban ser asignadas en el stack. Desde C\# 7.2, se introdujo el modificador \texttt{ref struct}.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{ref struct} en la declaración de estructuras.

\subsection*{Argumentos Nombrados No Finales}
\textbf{Problema:} En versiones anteriores, los argumentos nombrados debían colocarse al final de la lista de argumentos. Desde C\# 7.2, se permite mezclar argumentos posicionales y nombrados siempre que los posicionales estén primero.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir argumentos nombrados no finales.

\subsection*{Guiones Bajos Iniciales en Literales Numéricos}
\textbf{Problema:} Los literales numéricos no podían comenzar con guiones bajos (\texttt{\_}). Desde C\# 7.2, se permite usar guiones bajos iniciales antes de los dígitos impresos.

\textbf{Solución:} Se ajustó la gramática para permitir guiones bajos iniciales en literales numéricos.

\subsection*{Modificador \texttt{private protected}}
\textbf{Problema:} No había un modificador que combinara las restricciones de acceso \texttt{private} y \texttt{protected}. Desde C\# 7.2, se introdujo el modificador \texttt{private protected}, que permite acceso desde clases derivadas dentro del mismo ensamblado.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{private protected} en las reglas de acceso.

\subsection*{Expresiones Condicionales por Referencia}
\textbf{Problema:} En versiones anteriores, las expresiones condicionales (\texttt{?:}) no podían devolver referencias. Desde C\# 7.2, se permite que el resultado sea una referencia.

\textbf{Solución:} Se ajustó la gramática para permitir expresiones condicionales por referencia.


\subsection{C\# 7.3}

\subsection*{Acceso a Campos Fijos Sin Fijación}
\textbf{Problema:} En versiones anteriores de C\#, para acceder a campos fijos era necesario fijar la dirección de memoria. Desde C\# 7.3, se permite acceder a campos fijos sin necesidad de fijarlos explícitamente.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el acceso a campos fijos sin fijación.

\subsection*{Reasignación de Variables Locales Referenciadas}
\textbf{Problema:} No se podía reasignar variables locales referenciadas. Desde C\# 7.3, se permite la reasignación de variables locales que están marcadas como \texttt{ref}.

\textbf{Solución:} Se modificaron las reglas para permitir la reasignación de variables locales referenciadas.

\subsection*{Inicializadores en Arreglos Stackalloc}
\textbf{Problema:} No era posible utilizar inicializadores con arreglos creados con \texttt{stackalloc}. Desde C\# 7.3, se permite usar inicializadores en arreglos \texttt{stackalloc}.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir inicializadores en arreglos \texttt{stackalloc}.

\subsection*{Sentencias Fijas con Tipos que Soportan Patrones}
\textbf{Problema:} Las sentencias fijas solo podían usarse con tipos específicos. Desde C\# 7.3, se permiten sentencias fijas con cualquier tipo que soporte patrones.

\textbf{Solución:} Se modificó la regla \texttt{fixed\_statement} para permitir el uso con cualquier tipo que soporte patrones.

\subsection*{Pruebas con Tipos Tupla}
\textbf{Problema:} No se podía usar \texttt{==} y \texttt{!=} directamente con tipos tupla. Desde C\# 7.3, se permite comparar tuplas usando estos operadores.

\textbf{Solución:} Se modificaron las reglas para permitir comparaciones directas entre tipos tupla.

\subsection*{Uso de Variables de Expresión en Más Ubicaciones}
\textbf{Problema:} Las variables de expresión tenían un alcance limitado. Desde C\# 7.3, se permite usar variables de expresión en más ubicaciones dentro del código.

\textbf{Solución:} Se ajustaron las reglas gramaticales para ampliar el uso de variables de expresión en diferentes contextos.

\subsection*{Resolución de Métodos Mejorada al Usar Argumentos Diferentes por \texttt{in}}
\textbf{Problema:} La resolución de métodos al usar argumentos diferentes por \texttt{in} era confusa y poco clara. Desde C\# 7.3, se mejoró este aspecto.

\textbf{Solución:} Se ajustaron las reglas gramaticales para mejorar la resolución de métodos al usar argumentos por \texttt{in}.

\section{C\# 8}

\subsection*{Miembros Solo de Lectura \texttt{readonly}}
\textbf{Problema:} No se podía definir miembros de solo lectura en las clases. Desde C\# 8, se introdujeron los miembros solo de lectura, que permiten que las propiedades sean inmutables después de su inicialización.

\textbf{Solución:} Se modificó la regla \texttt{property\_declaration} para permitir miembros solo de lectura \texttt{readonly}.

\subsection*{Métodos de Interfaz por Defecto}
\textbf{Problema:} No era posible definir métodos en interfaces con una implementación por defecto. Desde C\# 8, se introdujeron métodos de interfaz por defecto, permitiendo que las interfaces contengan métodos implementados.

\textbf{Solución:} Se ajustó la regla \texttt{interface\_declaration} para permitir métodos de interfaz con implementación por defecto.

\subsection*{Mejoras en Coincidencia de Patrones}
\textbf{Problema:} Las versiones anteriores de C\# tenían limitaciones en los patrones disponibles. Desde C\# 8, se introdujeron mejoras en la coincidencia de patrones, incluyendo expresiones \texttt{switch} y patrones de propiedades.

\textbf{Solución:} Se expandieron las reglas \texttt{pattern} para incluir expresiones \texttt{switch} y patrones mejorados.

\subsection*{Patrones de Propiedades}
\textbf{Problema:} No había soporte para patrones que coincidieran con propiedades específicas. Desde C\# 8, se introdujeron patrones de propiedades para facilitar la coincidencia con las propiedades de un objeto.

\textbf{Solución:} Se modificó la regla \texttt{pattern} para incluir patrones que coincidan con propiedades.

\subsection*{Patrones Tupla}
\textbf{Problema:} No había soporte para coincidencias basadas en tuplas. Desde C\# 8, se introdujeron patrones tupla para facilitar la coincidencia con estructuras de tuplas.

\textbf{Solución:} Se agregó soporte para patrones tupla en la regla \texttt{pattern}.

\subsection*{Patrones Posicionales}
\textbf{Problema:} No había soporte para patrones que coincidieran con la posición de los elementos. Desde C\# 8, se introdujeron patrones posicionales que permiten coincidir elementos en una posición específica.

\textbf{Solución:} Se agregó soporte para patrones posicionales en la regla \texttt{pattern}.

\subsection*{Declaraciones Using}
\textbf{Problema:} Las declaraciones \texttt{using} debían estar al principio del archivo o dentro del bloque. Desde C\# 8, se permite utilizar declaraciones \texttt{using} dentro del bloque de código.

\textbf{Solución:} Se modificó la regla \texttt{using\_declaration} para permitir declaraciones \texttt{using} más flexibles.

\subsection*{Funciones Locales Estáticas}
\textbf{Problema:} Las funciones locales no podían ser estáticas antes. Desde C\# 8, se permite definir funciones locales como estáticas.

\textbf{Solución:} Se agregó soporte para funciones locales estáticas en la gramática.

\subsection*{Estructuras Ref Descartables}
\textbf{Problema:} No había un manejo específico para estructuras ref descartables. Desde C\# 8, se introdujo el soporte para estructuras ref descartables que permiten un manejo más eficiente de la memoria.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir estructuras ref descartables.

\subsection*{Tipos Nullable Referencia}
\textbf{Problema:} Todas las referencias eran consideradas no nulas. Desde C\# 8, se introdujo el concepto de tipos nullable referencia que permite indicar explícitamente si una referencia puede ser nula.

\textbf{Solución:} Se ajustaron las reglas gramaticales para incluir el manejo de tipos nullable referencia.

\subsection*{Flujos Asincrónicos}
\textbf{Problema:} No había un manejo eficiente para flujos asincrónicos. Desde C\# 8, se introdujo el soporte para flujos asincrónicos que permite trabajar con secuencias de datos asincrónicas.

\textbf{Solución:} Se modificaron las reglas gramaticales para permitir flujos asincrónicos y su uso en bucles.

\subsection*{Índices y Rangos}
\textbf{Problema:} No había una forma sencilla de trabajar con índices y rangos en colecciones. Desde C\# 8, se introdujo el soporte para índices y rangos que facilita el acceso a elementos en colecciones.

\textbf{Solución:} Se agregó soporte para índices y rangos en la gramática.

\subsection*{Asignación Null-Coalescing}
\textbf{Problema:} No había forma concisa de asignar valores cuando una variable es nula. Desde C\# 8, se introdujo el operador null-coalescing assignment (\texttt{??=}).

\textbf{Solución:} Se ajustó la gramática para incluir el operador null-coalescing assignment.

\subsection*{Tipos Construidos No Administrados}
\textbf{Problema:} No había un manejo específico para tipos construidos no administrados. Desde C\# 8, se introdujo el soporte para tipos construidos no administrados que permiten trabajar con tipos sin administración del recolector de basura.

\textbf{Solución:} Se agregó soporte para tipos construidos no administrados en la gramática.

\subsection*{Stackalloc en Expresiones Anidadas}
\textbf{Problema:} No era posible usar \texttt{stackalloc} dentro de expresiones anidadas. Desde C\# 8, se permite usar \texttt{stackalloc} dentro de expresiones anidadas.

\textbf{Solución:} Se ajustó la gramática para permitir el uso de \texttt{stackalloc} en expresiones anidadas.

\subsection*{Mejora en las Cadenas Interpoladas Verbatim}
\textbf{Problema:} Las cadenas interpoladas verbatim tenían limitaciones en su formato. Desde C\# 8, se mejoraron las cadenas interpoladas verbatim para permitir más flexibilidad al incluir expresiones complejas.

\textbf{Solución:} Se modificó la regla \texttt{interpolated\_string\_expression} para mejorar el manejo de cadenas interpoladas verbatim.



\section{C\# 9}

\subsection*{Registros \texttt{record}}

\textbf{Problema:} No existía un tipo de datos específico para registros. Sin embargo, desde C\# 9, se introdujeron los registros, que son tipos de referencia inmutables que facilitan la creación de objetos con propiedades.

\textbf{Solución:} Se modificó la regla \texttt{class\_declaration} para permitir la definición de \texttt{record}.

\subsection*{Setters Solo de Inicialización \texttt{init}}

\textbf{Problema:} Todas las propiedades podían ser modificadas después de su inicialización. Desde C\# 9, se introdujo la posibilidad de definir propiedades con setters solo de inicialización, permitiendo que las propiedades sean asignadas solo durante la creación del objeto.

\textbf{Solución:} Se ajustó la regla \texttt{property\_declaration} para incluir el modificador \texttt{init}.

\subsection*{Declaraciones en Nivel Superior}

\textbf{Problema:} El código debía estar contenido dentro de una clase o espacio de nombres. Desde C\# 9, se permite escribir declaraciones en nivel superior, lo que simplifica el código.

\textbf{Solución:} Se modificó la gramática para permitir declaraciones en nivel superior sin necesidad de definir una clase.

\subsection*{Mejoras en Coincidencia de Patrones}

\textbf{Problema:} Las versiones anteriores de C\# tenían limitaciones en los patrones disponibles. Desde C\# 9, se introdujeron mejoras en la coincidencia de patrones, incluyendo patrones relacionales y lógicos.

\textbf{Solución:} Se expandieron las reglas \texttt{pattern} para incluir patrones relacionales (>, <, $\leq$, $\geq$) y lógicos(or, and, not).

\subsection*{Enteros de Tamaño Nativo}

\textbf{Problema:} No había un tipo específico para enteros que se adaptara al tamaño nativo del sistema. Desde C\# 9, se introdujeron enteros de tamaño nativo (\texttt{nint} y \texttt{nuint}).

\textbf{Solución:} Se agregó soporte para los tipos \texttt{nint} y \texttt{nuint} en la regla \texttt{type\_}.

\subsection*{Punteros a Funciones}

\textbf{Problema:} No era posible trabajar con punteros a funciones directamente. Desde C\# 9, se introdujo el soporte para punteros a funciones.

\textbf{Solución:} Se agregó soporte para punteros a funciones en las reglas correspondientes.

\subsection*{Inicializadores de Módulo}

\textbf{Problema:} No había una forma específica de inicializar módulos. Desde C\# 9, se introdujeron inicializadores de módulo.

\textbf{Solución:} Se agregó soporte para inicializadores de módulo \texttt{[ModuleInitializer]} en la gramática.

\subsection*{Nuevas Funciones para Métodos Parciales}

\textbf{Problema:} Las funciones parciales tenían limitaciones en su uso. Desde C\# 9, se introdujeron nuevas características para métodos parciales.

\textbf{Solución:} Se ajustaron las reglas relacionadas con métodos parciales para incluir nuevas características.

\subsection*{Expresiones Nuevas con Tipos Objetivo}

\textbf{Problema:} No había una forma concisa de crear instancias utilizando tipos objetivo. Desde esta versión, se permite crear expresiones tipadas directamente.

\textbf{Solución:} Se ajustó la gramática para permitir expresiones tipadas al usar \texttt{new}.

\subsection*{Funciones Anónimas Estáticas}

\textbf{Problema:} Las funciones anónimas no podían ser estáticas anteriormente. Sin embargo, desde C\# 9, se permite definir funciones anónimas como estáticas.

\textbf{Solución:} Se agregó soporte para funciones anónimas estáticas en la gramática.

\subsection*{Expresiones Condicionales Tipadas por Objetivo}

\textbf{Problema:} Las expresiones condicionales no podían ser tipadas por objetivo antes. Desde C\# 9, se permite que las expresiones condicionales tengan un tipo objetivo inferido.

\textbf{Solución:} Se modificó la gramática para permitir expresiones condicionales tipadas por objetivo.

\subsection*{Tipos Retornados Covariantes}

\textbf{Problema:} Los tipos retornados covariantes \( c \, ? \, e_1 \, : \, e_2 \)
 no eran compatibles. Sin embargo, desde C\# 9, se introdujo el soporte para tipos retornados covariantes en métodos virtuales o sobrescritos.

\textbf{Solución:} Se ajustó la regla \texttt{method\_declaration} para permitir tipos retornados covariantes.

\subsection*{Soporte para Extensiones GetEnumerator en Bucles \texttt{foreach}}

\textbf{Problema:} El bucle \texttt{foreach} requería que las colecciones implementaran explícitamente \texttt{IEnumerable}. Con esta versión, se permite un soporte más flexible mediante extensiones \texttt{GetEnumerator}.

\textbf{Solución:} Se modificó la regla correspondiente al bucle \texttt{foreach} para incluir soporte para extensiones \texttt{GetEnumerator}.

\subsection*{Parámetros Descartados en Lambdas}

\textbf{Problema:} Los parámetros descartados no eran compatibles en expresiones lambda. Sin embargo, desde C\# 9, se permite usar parámetros descartados (\texttt{\_}) en lambdas.

\textbf{Solución:} Se ajustó la regla \texttt{lambda\_expression} para permitir parámetros descartados.

\subsection*{Atributos en Funciones Locales}

\textbf{Problema:} Anteriormente no era posible aplicar atributos a funciones locales. Sin embargo, desde C\# 9, se permite aplicar atributos a funciones locales definidas dentro de métodos.

\textbf{Solución:} Se modificó la regla correspondiente a los atributos para permitir su uso en funciones locales.

\subsection*{Uso del operador \texttt{with}}
\textbf{Problema:} Antes de C\# 9.0, no existía una forma concisa y directa de crear copias de objetos inmutables con algunas propiedades modificadas. Esto dificultaba la manipulación de objetos inmutables, ya que requería la creación manual de nuevos objetos con las propiedades deseadas.

\textbf{Solución:} Se modificó la regla \texttt{object\_initializer} para permitir el uso del operador \texttt{with}, que permite a los desarrolladores crear un nuevo objeto basado en uno existente y modificar solo las propiedades especificadas. Esto se implementó mediante la adición de una nueva regla \texttt{with\_expression} en la gramática, que permite la sintaxis \texttt{objeto with \{ propiedad = valor \}}.

\section{C\# 10}

\subsection*{Estructuras de Registro \texttt{record struct}}
\textbf{Problema:} Las estructuras de registro no estaban disponibles. Sin embargo, desde C\# 10, se introdujeron las estructuras de registro, que permiten definir estructuras con características de registro.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir estructuras de registro.

\subsection*{Manejadores de Cadenas Interpoladas}
\textbf{Problema:} No había una forma explícita de manejar las cadenas interpoladas. Sin embargo, desde C\# 10, se introdujeron los manejadores de cadenas interpoladas para mejorar su manejo.

\textbf{Solución:} Se ajustó la regla \texttt{interpolated\_string\_expression} para reconocer correctamente las expresiones dentro de cadenas interpoladas.

\subsection*{Directivas \texttt{using} Globales}
\textbf{Problema:} Las directivas \texttt{using} debían estar dentro de un espacio de nombres. Sin embargo, desde C\# 10, se permiten directivas \texttt{using} globales que pueden aplicarse a todo el archivo.

\textbf{Solución:} Se modificó la regla \texttt{using\_directive} para permitir directivas \texttt{using} globales.

\subsection*{Declaración de Espacios de Nombres \texttt{namespace} a Nivel de Archivo}
\textbf{Problema:} Los espacios de nombres debían declararse utilizando llaves (\texttt{\{\}}). Sin embargo, desde C\# 10, también es posible declararlos con punto y coma (\texttt{;}), permitiendo definiciones más concisas.

\textbf{Solución:} Se amplió la regla \texttt{namespace\_declaration} para soportar ambas sintaxis.

\subsection*{Patrones de Propiedades Extendidos}
\textbf{Problema:} Los patrones de propiedades no eran tan flexibles. Sin embargo, desde C\# 10, se extendieron los patrones de propiedades para permitir más flexibilidad en la coincidencia de patrones.

\textbf{Solución:} Se modificó la regla \texttt{pattern} para soportar patrones de propiedades extendidos \texttt{property\_pattern}.

\subsection*{Expresiones Lambda con Tipo Natural}
\textbf{Problema:} Las expresiones lambda debían tener un tipo explícito. Sin embargo, desde C\# 10, se permite que las expresiones lambda tengan un tipo natural, donde el compilador puede inferir el tipo delegado.

\textbf{Solución:} Se modificó la regla \texttt{lambda\_expression} para permitir tipos naturales en expresiones lambda.

\subsection*{Expresiones Lambda con Tipo de Retorno Explícito}
\textbf{Problema:} Las expresiones lambda no podían declarar un tipo de retorno explícito. Sin embargo, desde C\# 10, se permite que las expresiones lambda declaren un tipo de retorno cuando el compilador no puede inferirlo.

\textbf{Solución:} Se modificó la regla \texttt{lambda\_expression} para permitir tipos de retorno explícitos.

\subsection*{Atributos en Expresiones Lambda}
\textbf{Problema:} Los atributos no podían aplicarse a expresiones lambda. Sin embargo, desde C\# 10, se permite aplicar atributos a expresiones lambda.

\textbf{Solución:} Se modificó la regla \texttt{lambda\_expression} para permitir atributos.

\subsection*{Inicialización de Cadenas Constantes con Interpolación}
\textbf{Problema:} Las cadenas constantes no podían inicializarse con interpolación. Sin embargo, desde C\# 10, se permite inicializar cadenas constantes utilizando interpolación si todos los marcadores son cadenas constantes.

\textbf{Solución:} Se ajustó la regla \texttt{constant\_expression} para permitir interpolación en cadenas constantes.

\subsection*{Modificador \texttt{sealed} en \texttt{ToString} de Registros}
\textbf{Problema:} No había una forma explícita de sellar el método \texttt{ToString} en tipos de registro. Sin embargo, desde C\# 10, se permite agregar el modificador \texttt{sealed} cuando se sobrescribe \texttt{ToString} en un tipo de registro.

\textbf{Solución:} Se modificó la regla \texttt{method\_declaration} para permitir el modificador \texttt{sealed} en \texttt{ToString}.

\subsection*{Advertencias para Asignación Definida y Análisis de Estado Nulo}
\textbf{Problema:} Las advertencias para asignación definida y análisis de estado nulo no eran tan precisas. Sin embargo, desde C\# 10, se mejoraron estas advertencias para ser más precisas.

\textbf{Solución:} Se ajustó la regla \texttt{expression} para mejorar las advertencias relacionadas con la asignación definida y el análisis de estado nulo.

\subsection*{Declaración y Asignación en Deconstrucción}
\textbf{Problema:} La deconstrucción solo permitía declarar variables. Sin embargo, desde C\# 10, se permite tanto declarar como asignar valores en la misma deconstrucción.

\textbf{Solución:} Se modificó la regla \texttt{deconstruction\_expression} para permitir tanto declaraciones como asignaciones.

\subsection*{Atributo \texttt{AsyncMethodBuilder}}
\textbf{Problema:} No había una forma explícita de marcar métodos como constructores de métodos asíncronos. Sin embargo, desde C\# 10, se introdujo el atributo \texttt{AsyncMethodBuilder} para indicar métodos que construyen métodos asíncronos.

\textbf{Solución:} Se agregó soporte para el atributo \texttt{AsyncMethodBuilder}.

\subsection*{Atributo \texttt{CallerArgumentExpression}}
\textbf{Problema:} No había una forma explícita de obtener la expresión del argumento del llamador. Sin embargo, desde C\# 10, se introdujo el atributo \texttt{CallerArgumentExpression} para obtener esta información.

\textbf{Solución:} Se agregó soporte para el atributo \texttt{CallerArgumentExpression}.

\subsection*{Nuevo Formato para la Directiva \texttt{\#line}}
\textbf{Problema:} La directiva \texttt{\#line} no tenía un formato flexible. Sin embargo, desde C\# 10, se introdujo un nuevo formato para esta directiva que permite más flexibilidad.

\textbf{Solución:} Se modificó la regla \texttt{line\_directive} para soportar el nuevo formato.


\section{C\# 11}

\subsection*{Literales de Cadena Raw}

\textbf{Problema:} Las cadenas literales no podían contener caracteres especiales sin escaparlos. Sin embargo, desde C\# 11, se introdujeron los literales de cadena raw, que permiten cadenas sin necesidad de escapar caracteres especiales.

\textbf{Solución:} Se agregó soporte para los literales de cadena raw en la regla \texttt{string\_literal}.

\subsection*{Soporte Genérico para Operaciones Matemáticas}

\textbf{Problema:} Las operaciones matemáticas no podían ser genéricas. Sin embargo, desde C\# 11, se introdujo el soporte genérico para operaciones matemáticas, permitiendo definir métodos que trabajen con tipos numéricos genéricos.

\textbf{Solución:} Se modificó la regla \texttt{type\_} para permitir tipos genéricos en operaciones matemáticas.

\subsection*{Atributos Genéricos}

\textbf{Problema:} Los atributos no podían ser genéricos. Sin embargo, desde C\# 11, se introdujo el soporte para atributos genéricos, permitiendo definir atributos que acepten tipos genéricos.

\textbf{Solución:} Se modificó la regla \texttt{attribute} para permitir atributos genéricos.

\subsection*{Literales de Cadena UTF-8}

\textbf{Problema:} Las cadenas literales no podían especificar codificación UTF-8 explícitamente. Sin embargo, desde C\# 11, se introdujo el soporte para literales de cadena UTF-8, permitiendo especificar la codificación explícitamente.

\textbf{Solución:} Se agregó soporte para literales de cadena UTF-8 en la regla \texttt{string\_literal}.

\subsection*{Saltos de Línea en Expresiones Interpoladas}

\textbf{Problema:} Las expresiones interpoladas no permitían saltos de línea dentro de la cadena. Sin embargo, desde C\# 11, se permite incluir saltos de línea en expresiones interpoladas.

\textbf{Solución:} Se modificó la regla \texttt{interpolated\_string\_expression} para permitir saltos de línea.

\subsection*{Patrones de Lista}

\textbf{Problema:} Los patrones no podían aplicarse a listas. Sin embargo, desde C\# 11, se introdujo el soporte para patrones de lista, permitiendo comparar listas con patrones específicos.

\textbf{Solución:} Se agregó soporte para patrones de lista en la regla \texttt{pattern}.

\subsection*{Tipos Locales a Archivo}

\textbf{Problema:} Los tipos definidos debían ser accesibles desde cualquier parte del archivo. Sin embargo, desde C\# 11, se introdujo el soporte para tipos locales a archivo, permitiendo definir tipos que solo sean accesibles dentro del mismo archivo.

\textbf{Solución:} Se modificó la regla \texttt{class\_definition} para permitir tipos locales a archivo.

\subsection*{Miembros Obligatorios}

\textbf{Problema:} No había una forma explícita de marcar miembros como obligatorios. Sin embargo, desde C\# 11, se introdujo el soporte para miembros obligatorios, permitiendo definir miembros que deben ser inicializados.

\textbf{Solución:} Se agregó soporte para miembros obligatorios en la regla \texttt{property\_declaration}.

\subsection*{Estructuras con Valores Predeterminados}

\textbf{Problema:} Las estructuras no tenían valores predeterminados. Sin embargo, desde C\# 11, se introdujo el soporte para estructuras con valores predeterminados, permitiendo que las estructuras tengan valores por defecto.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir valores predeterminados en estructuras.

\subsection*{Coincidencia de Patrones con \texttt{Span\textless char\textgreater}}

\textbf{Problema:} Los patrones no podían aplicarse a \texttt{Span\textless char\textgreater}. Sin embargo, desde C\# 11, se introdujo el soporte para coincidir patrones con \texttt{Span\textless char\textgreater}.

\textbf{Solución:} Se agregó soporte para patrones con \texttt{Span\textless char\textgreater} en la regla \texttt{pattern}.

\subsection*{Alcance Extendido de \texttt{nameof}}

\textbf{Problema:} El operador \texttt{nameof} solo podía aplicarse a nombres de tipos y miembros. Sin embargo, desde C\# 11, se extendió el alcance de \texttt{nameof} para permitir su uso en más contextos.

\textbf{Solución:} Se modificó la regla \texttt{expression} para permitir el uso extendido de \texttt{nameof}.

\subsection*{Tipo \texttt{IntPtr} Numérico}

\textbf{Problema:} El tipo \texttt{IntPtr} no era numérico. Sin embargo, desde C\# 11, se introdujo el soporte para que \texttt{IntPtr} sea un tipo numérico.

\textbf{Solución:} Se modificó la regla \texttt{type\_} para permitir que \texttt{IntPtr} sea un tipo numérico.

\subsection*{Campos \texttt{ref} y \texttt{scoped ref}}

\textbf{Problema:} Los campos no podían ser \texttt{ref}. Sin embargo, desde C\# 11, se introdujo el soporte para campos \texttt{ref} y \texttt{scoped ref}, permitiendo definir campos que se comporten como referencias.

\textbf{Solución:} Se agregó soporte para campos \texttt{ref} en la regla \texttt{field\_declaration}.

\subsection*{Mejora en la Conversión de Grupos de Métodos a Delegados}

\textbf{Problema:} La conversión de grupos de métodos a delegados no era tan flexible. Sin embargo, desde C\# 11, se mejoró esta conversión para permitir más flexibilidad en la asignación de métodos a delegados.

\textbf{Solución:} Se modificó la regla \texttt{expression} para mejorar la conversión de grupos de métodos a delegados.

\section{C\# 12}

\subsection*{Constructores Primarios}

\textbf{Problema:} Los constructores deb\'ian definirse expl\'icitamente dentro de una clase o estructura. Desde C\# 12, se permite crear constructores primarios en cualquier tipo de clase o estructura.

\textbf{Soluci\'on:} Se modific\'o la regla \texttt{class\_definition} para permitir constructores primarios. Esto simplifica la definici\'on de clases y estructuras al combinar la declaraci\'on de par\'ametros con la inicializaci\'on de campos.

\subsection*{Expresiones de Colecci\'on}

\textbf{Problema:} Las colecciones se creaban utilizando el operador \texttt{new[]}. Desde C\# 12, se introdujo una nueva sintaxis para expresiones de colecci\'on, incluyendo el elemento de propagaci\'on (\texttt{..e}).

\textbf{Soluci\'on:} Se agreg\'o una nueva regla para soportar las expresiones de colecci\'on, definiendo la sintaxis de colecciones en l\'inea y el operador de propagaci\'on (\texttt{..e}).

\subsection*{Arrays en L\'inea}

\textbf{Problema:} Los arrays deb\'ian declararse con un tama\~no fijo utilizando llaves (\texttt{\{}). Desde C\# 12, se permite declarar arrays en l\'inea dentro de estructuras.

\textbf{Soluci\'on:} Se modific\'o la regla \texttt{type\_} para permitir arrays en l\'inea, simplificando la declaraci\'on de estructuras con arrays de tama\~no fijo.

\subsection*{Par\'ametros Opcionales en Expresiones Lambda}

\textbf{Problema:}Los par\'ametros en expresiones lambda no pod\'ian ser opcionales. Desde C\# 12, se permite el uso de par\'ametros opcionales en expresiones lambda.

\textbf{Soluci\'on:} Se actualiz\'o la regla \texttt{explicit\_anonymous\_function\_parameter} para soportar par\'ametros opcionales.

\subsection*{Par\'ametros \texttt{ref readonly}}

\textbf{Problema:} Los par\'ametros en expresiones lambda no pod\'ian ser \texttt{ref readonly}. Desde C\# 12, se permite el uso de par\'ametros \texttt{ref readonly} en expresiones lambda.

\textbf{Soluci\'on:} Se modific\'o la regla \texttt{explicit\_anonymous\_function\_parameter} para soportar par\'ametros \texttt{ref readonly}.

\subsection*{Alias Any Type}

\textbf{Problema:} El alias de tipo solo se pod\'ia utilizar con tipos nombrados. Desde C\# 12, se permite utilizar el alias de tipo con cualquier tipo.

\textbf{Soluci\'on:} Se actualiz\'o la regla \texttt{using\_directive} para permitir alias de cualquier tipo.

\subsection*{Atributo Experimental}

\textbf{Problema:} No hab\'ia una forma expl\'icita de marcar caracter\'isticas experimentales. Desde C\# 12, se introdujo el atributo \texttt{Experimental}.

\textbf{Soluci\'on:} Se agreg\'o soporte para el atributo \texttt{Experimental}.


\chapter{Extracción de features del AST}\label{chapter:proposal}

\section{Extraccion del AST}

 Se emplea ANTLR para extraer Árboles de Sintaxis Abstracta (AST) a partir del código fuente de programas escritos en C\#. Convierte una gramática de lenguaje en código que puede generar un árbol de sintaxis. \\
 A continuación, se explica su funcionamiento y las etapas principales en su flujo de trabajo:
 
 \begin{enumerate}
    \item \textbf{Definición de la Gramática:}
    Primero, se define la gramática del lenguaje en un archivo \texttt{.g4}. Este archivo incluye:
    \begin{itemize}
        \item \textbf{Reglas léxicas (tokens):} especifican los elementos más básicos, como palabras clave, identificadores, operadores, números, etc.
        \item \textbf{Reglas sintácticas:} describen cómo se combinan los tokens para formar sentencias válidas en el lenguaje.
    \end{itemize}
    Cada regla léxica o sintáctica tiene un nombre y una expresión que define qué secuencias de caracteres o estructuras pueden corresponderse con esa regla.

    \item \textbf{Generación del Lexer y el Parser:}
    ANTLR toma el archivo de gramática \texttt{.g4} y genera clases en un lenguaje de programación (como Java, Python, C\#, etc.) que implementan el lexer (analizador léxico) y el parser (analizador sintáctico).
    \begin{itemize}
        \item \textbf{Lexer:} identifica tokens en el texto de entrada. Por ejemplo, en una expresión matemática, reconoce números, operadores, paréntesis, etc.
        \item \textbf{Parser:} usa estos tokens para construir una estructura jerárquica que representa la gramática definida, lo cual permite reconocer la estructura completa del código o texto de entrada.
    \end{itemize}

    \item \textbf{Análisis del Código o Texto de Entrada:} Con el lexer y parser generados, se puede analizar el código fuente. Este proceso produce un árbol de sintaxis que representa la estructura jerárquica del código según la gramática.

    \item \textbf{Creación del Árbol de Sintaxis Abstracta (AST):} ANTLR facilita la creación de un AST, una representación simplificada que retiene la estructura lógica del código, omitiendo detalles innecesarios para ciertos tipos de análisis.

    \item \textbf{Recorridos y Transformaciones en el AST:} Una vez construido el AST, es posible recorrerlo para realizar análisis adicionales, transformaciones o para interpretar el código. ANTLR proporciona métodos para recorrer este árbol y manipular los nodos según las reglas definidas en la gramática, en este caso se utilizó el listener llamado {\bf CSharpParserListener}, proporcionado por ANTLR para recorrer el árbol y extraer los features.
\end{enumerate}



\section{Extraccion de features}

En el análisis de similitud de código y detección de patrones, es necesario extraer características relevantes que capturen la estructura y el comportamiento del código. Estas características, conocidas como {\bf features}, representan los aspectos más importantes de los datos, permitiendo analizar y comparar fragmentos de código de manera efectiva. Para este propósito, se implementó una clase llamada {\bf FeatureExtractorListener}, que extiende la funcionalidad de CSharpParserListener para analizar el código fuente en C\#. A continuación, se presenta una descripción detallada del proceso de extracción de características y la importancia de cada una. \\

\begin{enumerate}
	\item Estructura del AST:
    		\begin{itemize}
			\item {\bf total\_nodes:} Número total de nodos en el AST.
			\item {\bf max\_depth:} Profundidad máxima del AST.
		\end{itemize}
		
	 \item Declaraciones y Variables:
    \begin{itemize}
        \item {\bf variables:} Número de variables locales.
        \item {\bf constants:} Número de constantes declaradas.
        \item {\bf variable\_names:} Conjunto de nombres de variables y sus tipos.
        \item {\bf number\_of\_tuples:} Número de variables de tipo tupla.
        \item {\bf lists:} Número de listas declaradas.
        \item {\bf dicts:} Número de diccionarios declarados.
    \end{itemize}
    
Las variables y constantes son elementos clave en cualquier programa, ya que almacenan y mantienen valores que pueden cambiar o permanecer fijos durante la ejecución. Comprender el uso de estas entidades en el código permite analizar cómo se manipulan los datos, identificar el flujo de información y observar cómo evolucionan los valores a lo largo del programa. Las variables revelan el comportamiento dinámico del código, mientras que las constantes indican valores fijos que definen parámetros o condiciones estables dentro del flujo de ejecución.\\

Además, la variedad y el tipo de estructuras de datos empleadas, como tuplas, listas y diccionarios, aportan información importante sobre el enfoque y la complejidad del código. Por ejemplo, el uso de estructuras de datos más avanzadas, como diccionarios anidados o listas de objetos, puede reflejar una mayor abstracción y modularidad en el diseño, mientras que estructuras más simples pueden indicar un código directo y menos complejo. Estas elecciones también proporcionan información sobre el estilo de programación del autor y sus preferencias en cuanto a la organización y manipulación de datos.

    \item Declaraciones de Métodos y Clases:
    \begin{itemize}
        \item {\bf methods:} Número de métodos declarados.
        \item {\bf method\_names:} Conjunto de nombres de métodos.
        \item {\bf method\_return\_types:} Conjunto de tipos de retorno de métodos.
        \item {\bf method\_parameters:} Lista de parámetros de métodos.
        \item {\bf classes:} Número de clases declaradas.
        \item {\bf class\_names:} Conjunto de nombres de clases.
        \item {\bf abstract\_classes:} Número de clases abstractas.
        \item {\bf sealed\_classes:} Número de clases selladas.
        \item {\bf interfaces:} Número de interfaces declaradas.
        \item {\bf interface\_names:} Conjunto de nombres de interfaces.
    \end{itemize}
    
    La estructura y los nombres de los métodos y clases ofrecen información clave sobre la organización, modularidad y legibilidad del código. Los nombres de métodos y clases, cuando están bien definidos y siguen convenciones de nomenclatura clara, actúan como una especie de documentación implícita, ayudando a comprender la función y el propósito de cada componente sin necesidad de examinar cada detalle interno. 

Los métodos y sus parámetros son esenciales para entender la funcionalidad del código. Los métodos representan acciones específicas y los parámetros definen los datos con los que esas acciones trabajan. Al analizar los métodos y los tipos de parámetros que aceptan, se puede deducir cómo las distintas partes del código interactúan y colaboran para realizar tareas. La estructura de los métodos, su nivel de abstracción, y la forma en que interactúan con otros componentes del código revelan la profundidad de la modularidad y el diseño de la aplicación, lo que facilita el análisis de patrones y la identificación de similitudes entre diferentes fragmentos de código.

Por otro lado, las clases y sus tipos (como clases abstractas o selladas) indican la arquitectura y el paradigma de diseño de la aplicación. Las clases abstractas, por ejemplo, representan conceptos generales que definen una estructura básica sin implementación completa, alentando la reutilización y la extensibilidad en el diseño del sistema. Las clases selladas (sealed) limitan la herencia, sugiriendo un diseño más controlado y dirigido a la especificidad. Estas elecciones de diseño reflejan la intención del desarrollador en cuanto a la extensibilidad, la reutilización y la encapsulación, todos ellos principios fundamentales en la programación orientada a objetos.

    \item Estructuras de Control:
    \begin{itemize}
        \item {\bf control\_structures\_if:} Número de sentencias if.
        \item {\bf control\_structures\_switch:} Número de sentencias switch.
        \item {\bf control\_structures\_for:} Número de bucles for.
        \item {\bf control\_structures\_while:} Número de bucles while.
        \item {\bf control\_structures\_dowhile:} Número de bucles do-while.
        \item {\bf try\_catch\_blocks:} Número de bloques try-catch.
    \end{itemize}
    
    Las estructuras de control son fundamentales para comprender el flujo del programa y su lógica. Un mayor número de estructuras de control indica una lógica más compleja y ramificada.

    \item Modificadores y Accesibilidad:
    \begin{itemize}
        \item {\bf access\_modifiers\_public:} Número de elementos públicos.
        \item {\bf access\_modifiers\_private:} Número de elementos privados.
        \item {\bf access\_modifiers\_protected:} Número de elementos protegidos.
        \item {\bf access\_modifiers\_internal:} Número de elementos internos.
        \item {\bf access\_modifiers\_static:} Número de elementos estáticos.
        \item {\bf access\_modifiers\_protected\_internal:} Número de elementos protegidos internos.
        \item {\bf access\_modifiers\_private\_protected:} Número de elementos privados protegidos.
    \end{itemize}
    Los modificadores de acceso proporcionan información sobre la encapsulación y visibilidad de los componentes del código. La prevalencia de ciertos modificadores puede indicar prácticas de diseño y seguridad en el código.

    \item Modificadores Específicos:
    \begin{itemize}
        \item {\bf modifier\_readonly:} Número de elementos readonly.
        \item {\bf modifier\_volatile:} Número de elementos volatile.
        \item {\bf modifier\_virtual:} Número de elementos virtual.
        \item {\bf modifier\_override:} Número de elementos override.
        \item {\bf modifier\_new:} Número de elementos new.
        \item {\bf modifier\_partial:} Número de elementos partial.
        \item {\bf modifier\_extern:} Número de elementos extern.
        \item {\bf modifier\_unsafe:} Número de elementos unsafe.
        \item {\bf modifier\_async:} Número de elementos async.
    \end{itemize}
    
    Estos modificadores específicos reflejan patrones de diseño, control y comportamiento que van más allá de la simple estructura superficial del código. Al analizar modificadores como readonly, volatile o async, se capturan detalles sobre cómo el código maneja la concurrencia, la inmutabilidad y la asincronía, se utilizan para identificar similitudes en la lógica y el flujo de ejecución. Modificadores como virtual y override indican una arquitectura orientada a objetos, esto permite comparar el grado de extensibilidad y personalización en diferentes fragmentos de código. Además, la presencia de unsafe y extern sugiere que el código interactúa con recursos de bajo nivel o externos, lo que proporciona información sobre la complejidad y las dependencias de cada implementación.\\

    \item Llamadas a Librerías y LINQ(Language Integrated Query):
    \begin{itemize}
        \item {\bf library\_call\_console:} Número de llamadas a la librería Console.
        \item {\bf library\_call\_math:} Número de llamadas a la librería Math.
        \item {\bf linq\_queries\_select:} Número de consultas LINQ Select.
        \item {\bf linq\_queries\_where:} Número de consultas LINQ Where.
        \item {\bf linq\_queries\_orderBy:} Número de consultas LINQ OrderBy.
        \item {\bf linq\_queries\_groupBy:} Número de consultas LINQ GroupBy.
        \item {\bf linq\_queries\_join:} Número de consultas LINQ Join.
        \item {\bf linq\_queries\_sum:} Número de consultas LINQ Sum.
        \item {\bf linq\_queries\_count:} Número de consultas LINQ Count.
    \end{itemize}
    
    Las llamadas a librerías y las consultas LINQ ofrecen información sobre cómo el código aprovecha las funcionalidades estándar y gestiona la manipulación de datos. Al utilizar llamadas a librerías, el código accede a un conjunto de herramientas predefinidas y optimizadas. Esto permite deducir la experiencia y el estilo del programador en términos de modularidad y adaptabilidad, aspectos clave en la estructura y lógica del código.\\

Por otro lado, el uso de consultas LINQ para manipular y consultar colecciones de datos refleja un enfoque específico en la optimización y claridad de la manipulación de datos en .NET. LINQ permite un acceso eficiente a estructuras de datos complejas, proporcionando una sintaxis uniforme para realizar operaciones como filtrado, proyección, agrupación y ordenación. La presencia de consultas LINQ en el código puede indicar la preferencia del desarrollador por una sintaxis declarativa y una gestión avanzada de colecciones, que resulta fundamental para identificar similitudes en la forma en que diferentes fragmentos de código manejan datos.

    \item Otras Características:
    \begin{itemize}
        \item {\bf number\_of\_lambdas:} Número de expresiones lambda.
        \item {\bf number\_of\_getters:} Número de métodos get.
        \item {\bf number\_of\_setters:} Número de métodos set.
        \item {\bf number\_of\_namespaces:} Número de espacios de nombres.
        \item {\bf enums:} Número de enumeraciones.
        \item {\bf enum\_names:} Conjunto de nombres de enumeraciones.
        \item {\bf delegates:} Número de delegados.
        \item {\bf delegate\_names:} Conjunto de nombres de delegados.
        \item {\bf node\_count:} Conteo de nodos por tipo.
    \end{itemize}
    Estas características adicionales permiten analizar el código desde distintas perspectivas que revelan aspectos de diseño y organización. Por ejemplo, el número de expresiones lambda indica la frecuencia de uso de funciones anónimas, lo cual puede reflejar una orientación hacia la programación funcional. La cantidad de métodos de acceso ofrece una idea del manejo de encapsulamiento y control de atributos en las clases. La presencia de espacios de nombres sugiere la estructura modular del código y la separación de responsabilidades, lo que facilita la organización y evita conflictos de nombres. Las enumeraciones y los delegados muestran la variedad de estructuras y tipos personalizados utilizados. Finalmente, el conteo de nodos por tipo permite una visión detallada de los elementos específicos del árbol de sintaxis abstracta, lo cual es útil para evaluar la complejidad y el tipo de construcciones empleadas.
 
\end{enumerate}
    
        
La extracción de características con FeatureExtractorListener permite capturar aspectos relevantes del código fuente en C\#, desde su estructura y complejidad hasta los patrones de diseño y las prácticas de programación. La implementación y el análisis detallado de estas características proporcionan una base sólida para mejorar la precisión de las herramientas de análisis de código.



\chapter{Preparacion del dataset}\label{chapter:proposal}

Para preparar el dataset, se convierten los nombres de variables, métodos y otros identificadores de tipo string en vectores de características numéricas, lo cual permite que un modelo de machine learning procese el código de manera efectiva. Este proceso de transformación se realiza utilizando embeddings, una técnica de procesamiento del lenguaje natural, mediante el modelo Word2Vec \cite{mikolov2013efficient}. Estos embeddings se combinan con otras características numéricas extraídas del código, como el número de métodos o la cantidad de expresiones lambda, lo cual forma un vector de características completo. Este vector integrado proporciona una descripción multidimensional del código, capturando tanto la estructura como la semántica en una única representación, lo que mejora la capacidad del modelo para detectar patrones y realizar comparaciones entre diferentes fragmentos de código.

\section{Construcción del dataset}

El dataset de códigos en C\# está compuesto por pares de archivos que mantienen la misma funcionalidad pero presentan variaciones en la estructura y nomenclatura. Cada par está compuesto por un archivo original y su respectiva copia, con cambios mínimos y modificaciones que buscan simular escenarios típicos en los que el código mantiene su esencia lógica pero experimenta alteraciones en la sintaxis y organización, abarcan desde algoritmos fundamentales de programación hasta aplicaciones prácticas en la vida diaria.

 Se eligieron las principales inteligencias artificiales generativas mas utilizados para la generación de código pues cuenta con 300 archivos generados por ChatGPT, 300 por Copilot, 150 con Perplexity y 90 con Phind donde la mitad son originales y la mitad son copias, teniendo un total de 1000 códigos. 

\begin{enumerate}
    \item \textbf{Creación de Código Base}: Se crearon múltiples fragmentos de código en C\# que abarcan una variedad de funciones comunes, como cálculos geométricos, operaciones matemáticas, manipulación de cadenas de texto y validaciones de números. Estos fragmentos de código están diseñados para ejecutar funciones claras y específicas. 

    \item \textbf{Generación de Copias con Modificaciones}: Para cada archivo original, se generó una copia modificada siguiendo varias estrategias de variación:
    \begin{itemize}
        \item \textit{Renombramiento de Clases, Métodos y Variables}: Los nombres de clases, métodos y variables fueron modificados en las copias para simular diferencias en nomenclatura sin cambiar el objetivo funcional del código.
        \item \textit{Modificación de Estructura de Código}: Se alteraron estructuras sintácticas, como el tipo de bucles (de \texttt{for} a \texttt{while}) o la reestructuración de condiciones lógicas. Estas modificaciones permiten que la copia mantenga la misma funcionalidad que el original, pero con una apariencia diferente en términos de código.
        \item \textit{Ajustes en la Organización}: Algunos fragmentos fueron reorganizados en cuanto al orden de ejecución o el uso de estructuras de control alternativas, manteniendo los resultados finales consistentes con el código original.
    \end{itemize}
\end{enumerate}

\section{Dataset de diferencias}

Para maximizar la cantidad de datos disponibles y reflejar de manera efectiva la similitud entre proyectos, se creó un dataset que contiene todos los pares posibles (2 a 2) de proyectos del conjunto de datos original. En este proceso, para cada par de proyectos, se calcula y almacena la diferencia entre sus vectores correspondientes.\\

Este enfoque tiene varias ventajas significativas:

\begin{itemize}
	\item {\bf Incremento en la Cantidad de Datos:} Generar todos los pares posibles de proyectos incrementa exponencialmente el número de instancias en el dataset, proporcionando una base de datos más rica y diversa para entrenar modelos de aprendizaje automático.
	
	\item {\bf Etiquetado Automático de Datos:} Una ventaja de calcular la distancia entre los datos es que permite disponer de algunos datos etiquetados. Aunque no se puede afirmar si un proyecto individual es original o una copia de otro proyecto, al calcular las distancias dos a dos, se puede asegurar que un par de proyectos provenientes de diferentes tipos de proyectos no son copias uno del otro. Esto proporciona etiquetas adicionales que mejoran la calidad del entrenamiento del modelo.

	\item {\bf Captura de Relaciones Detalladas:} Al almacenar la diferencia entre los vectores de cada par de proyectos, se capturan las distancias y relaciones específicas entre todos los proyectos. Esto permite que el modelo de machine learning pueda aprender las sutilezas de las similitudes y diferencias entre distintos proyectos.
	
	\item {\bf Mejora en la Precisión del Modelo:} Con un mayor volumen de datos y la inclusión de las distancias entre pares, se espera que el modelo tenga un mejor desempeño en la tarea de detección de similitudes. La precisión del modelo se ve beneficiada al disponer de más ejemplos que reflejan una amplia gama de variaciones y similitudes.
	
	\item {\bf Refinamiento de las Métricas de Similitud:} Este método permite que se utilicen métricas de similitud precisas, ya que cada par de proyectos se compara de manera detallada. 

\end{itemize}

En resumen, la creación de este dataset con todos los pares posibles y sus diferencias vectoriales no solo aumenta la cantidad de datos disponibles, sino que también enriquece la información sobre las relaciones entre proyectos, mejorando así la capacidad del modelo para detectar similitudes de manera precisa y eficiente.  


\section{Word2Vec}

En el contexto del análisis de similitud de código, los nombres de variables, métodos y otros identificadores en el código fuente proporcionan información semántica sobre la funcionalidad y el propósito de diferentes partes del código. Por ejemplo, los identificadores que se usan de manera similar en diferentes contextos tendrán embeddings\footnote{Los embeddings son una técnica de procesamiento de lenguaje natural que convierte el lenguaje humano en vectores matemáticos. Estos vectores son una representación del significado subyacente de las palabras, lo que permite que las computadoras procesen el lenguaje de manera más efectiva.} similares. Sin embargo, los identificadores en el código no están estructurados de manera que las máquinas puedan comprender fácilmente sus relaciones semánticas, para esto se utilizó Word2Vec. El proceso involucró los siguientes pasos:

\begin{enumerate}
	\item \textit{Extracción de Identificadores}: Se extrajeron todos los nombres de variables, métodos, clases, interfaces, enumeraciones y delegados del código fuente utilizando la clase FeatureExtractorListener.
	
	\item \textit{Entrenamiento de Word2Vec}: Se utilizó un corpus de identificadores extraídos de múltiples proyectos de C\# para entrenar el modelo Word2Vec. El modelo aprendió las relaciones semánticas entre los diferentes identificadores en el contexto del código.
	
	\item \textit{Conversión a Embeddings}: Cada identificador extraído se convirtió en un vector de características numéricas utilizando el modelo Word2Vec entrenado. Luego se halla el promedio entre todos los vectores por feature correspondiente para asegurar que todos las caracteristicas de vectores tengan la misma dimensión. Estos vectores capturan la semántica y el contexto de los identificadores en el código.
	 
\end{enumerate}


\chapter{Redes Neuronales Siamesas para la Similitud de Código}\label{chapter:proposal}

Las redes neuronales siamesas se emplearon para analizar y capturar tanto la estructura como el comportamiento lógico del código. Este enfoque facilita la identificación de patrones, relaciones textuales y sintácticas, proporcionando una mayor precisión en los resultados obtenidos. En este capítulo se detallan los componentes esenciales de esta arquitectura y el proceso llevado a cabo para su entrenamiento.

\section{Concepto de Red Siamesa}

Una red neuronal siamesa consta de dos subredes idénticas que procesan dos entradas en paralelo y producen representaciones vectoriales latentes. La arquitectura básica es la siguiente:
\begin{itemize}
    \item \textbf{Entrada:} Dos vectores \(x_1\) y \(x_2\) de tamaño \(n\).
    \item \textbf{Subred Base:} Ambas entradas se procesan mediante una red compartida \(f_\theta\), obteniendo:
    \[
    h_1 = f_\theta(x_1), \quad h_2 = f_\theta(x_2).
    \]
    \item \textbf{Métrica de Distancia:} La similitud entre las representaciones latentes se mide mediante una distancia, como:
    \[
    d(h_1, h_2) = ||h_1 - h_2||_p,
    \]
    donde \(p = 1\) para la distancia \(L1\) o \(p = 2\) para la distancia Euclidiana.
    \item \textbf{Clasificación Binaria:} La distancia se pasa por una capa de activación sigmoidal para obtener una probabilidad:
    \[
    \hat{y} = \sigma(W \cdot d(h_1, h_2) + b).
    \]
\end{itemize}

\section{Implementación del Modelo}

Esta sección describe cómo se implementa un modelo de red siamesa utilizando TensorFlow/Keras. La implementación incluye tres componentes clave: la subred base, la arquitectura siamesa y los mecanismos de optimización.

\subsection{Subred Base}

La subred base transforma las entradas crudas \( x \in \mathbb{R}^{65} \) en representaciones vectoriales compactas y abstractas. Este proceso ayuda al modelo a identificar patrones relevantes y eliminar información redundante.

\begin{enumerate}
    \item \textbf{Capa densa (\textit{Dense}):} Cada capa densa aplica una transformación lineal seguida de una función de activación no lineal \textbf{ReLU} (Rectified Linear Unit). La fórmula matemática para una capa es:
    \[
    h^{(l)} = \text{ReLU}(W^{(l)} \cdot h^{(l-1)} + b^{(l)}),
    \]
    donde:
    \begin{itemize}
        \item \( W^{(l)} \) es la matriz de pesos.
        \item \( b^{(l)} \) es el vector de sesgos.
        \item \( h^{(l)} \) es la salida de la capa \( l \).
    \end{itemize}
    
    \item \textbf{Regularización con \textit{Dropout}:} Dropout apaga aleatoriamente una proporción \( p = 0.5 \) de las neuronas en cada capa durante el entrenamiento. Esto previene el sobreajuste del modelo.

    \item \textbf{Arquitectura detallada:} La subred consta de:
    \begin{itemize}
        \item Entrada \( x \in \mathbb{R}^{65} \), donde cada dimensión es una característica del conjunto de datos.
        \item Tres capas densas con tamaños decrecientes (512, 256, y 128 neuronas) y activaciones \textbf{ReLU}.
        \item Salida \( h(x) \in \mathbb{R}^{128} \), un vector de representación latente que condensa la información relevante de las entradas.
    \end{itemize}
\end{enumerate}

Esta arquitectura es compartida entre las dos ramas del modelo siamesa.

\subsection{Construcción del Modelo Siamesa}

El modelo siamesa utiliza dos copias idénticas de la subred base para procesar dos entradas, compararlas y calcular una probabilidad de similitud.

\begin{enumerate}
    \item \textbf{Entradas:} Dos vectores \( x_1, x_2 \in \mathbb{R}^{65} \) que representan las instancias a comparar.

    \item \textbf{Representaciones Latentes:} Cada entrada se transforma en una representación latente compacta mediante la subred base:
    \[
    h_1 = f_\theta(x_1), \quad h_2 = f_\theta(x_2),
    \]
    donde \( f_\theta \) representa la subred base con parámetros compartidos \( \theta \).

    \item \textbf{Cálculo de la Distancia L1:} Para medir la similitud entre las representaciones latentes, se calcula la distancia L1:
    \[
    d(h_1, h_2) = |h_1 - h_2|.
    \]
    Esto se implementa utilizando una capa \textbf{Lambda} en TensorFlow/Keras.

    \item \textbf{Clasificación:} La distancia calculada se pasa a una capa densa con una activación sigmoidal (\textbf{sigmoid}) que produce una probabilidad:
    \[
    \hat{y} = \sigma(W \cdot d(h_1, h_2) + b),
    \]
    donde:
    \begin{itemize}
        \item \( W \) son los pesos de la capa.
        \item \( b \) es el sesgo.
        \item \( \sigma(z) = \frac{1}{1 + e^{-z}} \) convierte \( z \) en un valor entre 0 y 1, interpretado como la probabilidad de similitud.
    \end{itemize}
\end{enumerate}

\subsection{Función de Pérdida}

El modelo se entrena minimizando la entropía cruzada binaria, que mide la discrepancia entre las probabilidades predichas (\( \hat{y} \)) y las etiquetas verdaderas (\( y \)):

\[
\mathcal{L} = - \frac{1}{N} \sum_{i=1}^N \Big[ y_i \cdot \log(\hat{y}_i) + (1 - y_i) \cdot \log(1 - \hat{y}_i) \Big],
\]
donde:
\begin{itemize}
    \item \( y_i \in \{0, 1\} \) indica si los pares de entrada son similares (\(1\)) o diferentes (\(0\)).
    \item \( \hat{y}_i \in [0, 1] \) es la probabilidad predicha por el modelo para el par \( i \).
\end{itemize}

Esta función penaliza predicciones incorrectas de manera proporcional a su magnitud.

\subsection{Optimización}

El modelo utiliza el optimizador \textbf{Adam} (Adaptive Moment Estimation) para ajustar los pesos \( \theta \). Adam combina las ventajas de:
\begin{itemize}
    \item \textbf{Momentum:} Acelera el entrenamiento en direcciones consistentes.
    \item \textbf{Tasas de aprendizaje adaptativas:} Ajusta la tasa de aprendizaje individual para cada parámetro.
\end{itemize}

El algoritmo de Adam se define como:
\begin{enumerate}
    \item Estimación del primer momento (media):
    \[
    m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t,
    \]
    donde \( g_t \) es el gradiente en el paso \( t \).

    \item Estimación del segundo momento (varianza):
    \[
    v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2.
    \]

    \item Actualización de los parámetros:
    \[
    \theta_{t+1} = \theta_t - \alpha \frac{m_t}{\sqrt{v_t} + \epsilon}.
    \]
\end{enumerate}

Los hiperparámetros típicos son \( \beta_1 = 0.9 \), \( \beta_2 = 0.999 \), y \( \epsilon = 10^{-8} \). Adam combina estabilidad y velocidad, logrando convergencia eficiente en problemas complejos.


\section{Proceso de Entrenamiento y Predicción}

En esta sección, explicamos cómo se lleva a cabo el proceso de entrenamiento y predicción en el modelo siamesa, enfatizando cómo los pares de datos son utilizados para aprender las representaciones y cómo se realiza la inferencia posterior para predecir la similitud entre las entradas.

\subsection{Entrenamiento}

El modelo siamesa se entrena utilizando un conjunto de pares de datos \( (x_1, x_2, y) \), donde \( x_1 \) y \( x_2 \) son dos instancias que se comparan entre sí, y \( y \) es la etiqueta binaria que indica si las instancias son similares (\(y = 1\)) o disímiles (\(y = 0\)).

Durante el entrenamiento, el modelo ajusta los pesos para minimizar la función de pérdida sobre todo el conjunto de entrenamiento. La optimización se realiza utilizando el algoritmo de Adam, como se mencionó anteriormente, que es capaz de actualizar los pesos de manera eficiente. El proceso de entrenamiento se realiza mediante el método \texttt{model.fit}, el cual toma los datos de entrada y las etiquetas correspondientes:

\[
\text{model.fit}([x_1, x_2], y, \text{validation\_data}=([x_1^{val}, x_2^{val}], y^{val})).
\]

Aquí, \( [x_1, x_2] \) son las dos entradas que representan un par de datos de entrenamiento, y \( y \) es la etiqueta correspondiente. Además, se proporciona un conjunto de validación \( ([x_1^{val}, x_2^{val}], y^{val}) \) para evaluar el rendimiento del modelo durante el entrenamiento y prevenir el sobreajuste. La validación permite que el modelo se ajuste y aprenda sin memorizar excesivamente los datos de entrenamiento, lo que puede llevar a una mala generalización.

El modelo procesa cada par de entradas \( x_1, x_2 \) a través de la subred base, calculando sus representaciones latentes \( h_1 \) y \( h_2 \). Luego, calcula la distancia entre estas representaciones y utiliza esta información para realizar una predicción \( \hat{y} \), que se compara con la etiqueta \( y \) en la función de pérdida. A medida que el modelo se entrena, ajusta sus pesos para minimizar la discrepancia entre las predicciones \( \hat{y} \) y las etiquetas \( y \).

\subsection{Predicción}

Una vez que el modelo ha sido entrenado, se puede utilizar para hacer predicciones sobre nuevos pares de datos \( (x_1, x_2) \). En este caso, el modelo toma las dos entradas \( x_1 \) y \( x_2 \), las pasa a través de la subred base para obtener sus representaciones latentes \( h_1 \) y \( h_2 \), y luego calcula la distancia entre ellas utilizando la métrica L1.

A continuación, el modelo predice la similitud entre los dos elementos utilizando la fórmula:

\[
\text{similarity} = \text{model.predict}([x_1, x_2]).
\]

El valor de \texttt{similarity} es un valor entre 0 y 1, que indica qué tan similares son las dos entradas. Un valor cercano a 0 indica que las entradas son similares, mientras que un valor cercano a 1 indica que son disímiles. Esto se debe a que el modelo genera una probabilidad, y la activación sigmoidal transforma la distancia entre las representaciones latentes en un valor de probabilidad. La salida final, \( \hat{y} \), se interpreta como la probabilidad de que las dos entradas pertenezcan a la misma clase (es decir, que sean similares).

