\chapter{Modificaciones a la Gramática de ANTLR para Soporte de C\# Actual}\label{chapter:proposal}

ANTLR (Another Tool for Language Recognition) cuenta con una gramática basada en C\# 6.0. Sin embargo, dado que la versión actual de C\# es 12.0 (introducida en noviembre de 2023), esta gramática presentaba limitaciones significativas al trabajar con el código moderno. Esto generaba errores durante el análisis sintáctico y resultaba en un árbol de sintaxis abstracta (AST) incompleto. \\

Dado que el lenguaje C\# ha evolucionado considerablemente desde la versión 6.0, era necesario actualizar la gramática para reflejar las características introducidas en versiones posteriores. A continuación, se describen los principales problemas encontrados y las modificaciones realizadas para solventarlos.

\section{C\# 7.0}

\subsection{Variables \texttt{out}}
\textbf{Problema:} En versiones anteriores de C\#, el uso de variables \texttt{out} requería una declaración previa. Desde C\# 7.0, se permite declarar variables directamente en la declaración del método.

\textbf{Solución:} Se modificó la gramática para permitir la declaración de variables \texttt{out} directamente en la llamada al método.

\subsection{Tuplas y Deconstrucción}
\textbf{Problema:} En versiones anteriores, las tuplas no eran un tipo nativo y requerían una biblioteca externa. Desde C\# 7.0, se introdujeron tuplas como un tipo nativo, permitiendo la deconstrucción de sus elementos.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el uso de tuplas nativas y la deconstrucción.

\subsection{Coincidencia de Patrones}
\textbf{Problema:} En versiones anteriores, no había soporte para coincidencia de patrones en C\#. Desde C\# 7.0, se introdujo la coincidencia de patrones que permite simplificar el código al verificar tipos y valores.

\textbf{Solución:} Se agregó soporte para coincidencia de patrones en la gramática.

\subsection{Funciones Locales}
\textbf{Problema:} En versiones anteriores, las funciones debían estar definidas a nivel de clase. Desde C\# 7.0, se introdujeron funciones locales que permiten definir funciones dentro de métodos.

\textbf{Solución:} Se modificó la gramática para permitir la definición de funciones locales dentro de métodos.

\subsection{Miembros Expresados con Cuerpo de Expresión Expandido}
\textbf{Problema:} En versiones anteriores, los miembros debían tener un cuerpo completo. Desde C\# 7.0, se introdujo la posibilidad de usar cuerpos de expresión para simplificar la definición de miembros.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir cuerpos de expresión en miembros.

\subsection{Locales \texttt{ref}}
\textbf{Problema:} En versiones anteriores, no era posible utilizar locales \texttt{ref} que permiten referenciar variables directamente en lugar de copiar su valor. Desde C\# 7.0, se introdujeron los locales \texttt{ref}.

\textbf{Solución:} Se agregó soporte para locales \texttt{ref} en la gramática.

\subsection{Retornos \texttt{ref}}
\textbf{Problema:} En versiones anteriores, los métodos no podían devolver referencias directamente. Desde C\# 7.0, se introdujo el soporte para retornos \texttt{ref}, permitiendo que un método devuelva una referencia a un valor existente.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir retornos \texttt{ref}.

\subsection{Discards}
\textbf{Problema:} En versiones anteriores, no había una forma explícita de ignorar valores en asignaciones o expresiones. Desde C\# 7.0, se introdujo el uso de discards (\texttt{\_}) que permite omitir valores que no son necesarios.

\textbf{Solución:} Se modificó la gramática para permitir el uso del símbolo \texttt{\_} como discard.

\subsection{Literales Binarios y Separadores de Dígitos}
\textbf{Problema:} En versiones anteriores, no había soporte para literales binarios ni separadores de dígitos en números. Desde C\# 7.0, se introdujeron literales binarios y la capacidad de usar guiones bajos como separadores en literales numéricos.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir literales binarios y separadores de dígitos.

\subsection{Expresiones \texttt{throw}}
\textbf{Problema:} En versiones anteriores, las expresiones \texttt{throw} solo podían usarse en instrucciones completas. Desde C\# 7.0, se introdujeron expresiones \texttt{throw}, permitiendo lanzar excepciones como parte de expresiones más complejas.

\textbf{Solución:} Se modificó la gramática para permitir expresiones \texttt{throw}.


\section{C\# 7.1}

\subsection{Método \texttt{Main} Asíncrono}
\textbf{Problema:} En versiones anteriores de C\#, el método de entrada \texttt{Main} no podía ser asíncrono. Esto limitaba el uso de operaciones asincrónicas en la inicialización de aplicaciones. Desde C\# 7.1, se permite que el método \texttt{Main} tenga el modificador \texttt{async}.


\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el modificador \texttt{async} en el método de entrada \texttt{Main}.

\subsection{Expresiones Literales por Defecto (\texttt{default})}
\textbf{Problema:} En versiones anteriores, era necesario especificar explícitamente el tipo al usar valores predeterminados. Desde C\# 7.1, se introdujeron las expresiones literales \texttt{default}, que infieren automáticamente el tipo cuando es posible.

\textbf{Solución:} Se modificó la gramática para permitir expresiones literales \texttt{default} en contextos donde el tipo puede inferirse.

\subsection{Inferencia de Nombres de Elementos en Tuplas}
\textbf{Problema:} En versiones anteriores, era necesario nombrar explícitamente los elementos de una tupla al inicializarla. Desde C\# 7.1, se permite inferir los nombres de los elementos a partir de las variables utilizadas en la inicialización.

\textbf{Solución:} Se ajustaron las reglas gramaticales para inferir automáticamente los nombres de los elementos en inicializaciones de tuplas.

\subsection{Coincidencia de Patrones en Parámetros Genéricos}
\textbf{Problema:} En versiones anteriores, no era posible realizar coincidencia de patrones en variables cuyo tipo era un parámetro genérico. Desde C\# 7.1, se permite realizar coincidencias de patrones en este caso.

\textbf{Solución:} Se expandieron las reglas para permitir coincidencia de patrones en variables con tipos genéricos.


\section{C\# 7.2}

\subsection{Inicializadores en Arreglos Stackalloc}
\textbf{Problema:} En versiones anteriores de C\#, no era posible inicializar directamente los arreglos creados con \texttt{stackalloc}. Desde C\# 7.2, se permite usar inicializadores en arreglos \texttt{stackalloc}.

\textbf{Solución:} Se ajustó la gramática para permitir inicializadores en arreglos creados con \texttt{stackalloc}.

\subsection{Uso de Sentencias Fijas con Tipos que Soportan Patrones}
\textbf{Problema:} En versiones anteriores, las sentencias \texttt{fixed} solo podían usarse con tipos específicos como arreglos o cadenas. Desde C\# 7.2, se permite usar sentencias \texttt{fixed} con cualquier tipo que soporte un patrón.

\textbf{Solución:} Se modificó la regla \texttt{fixed\_statement} para permitir el uso de cualquier tipo que soporte patrones.

\subsection{Acceso a Campos Fijos Sin Fijación}
\textbf{Problema:} En versiones anteriores, para acceder a campos fijos era necesario fijar la dirección de memoria explícitamente. Desde C\# 7.2, se permite acceder a campos fijos sin necesidad de fijarlos.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el acceso a campos fijos sin fijación explícita.

\subsection{Reasignación de Variables Locales Referenciadas}
\textbf{Problema:} En versiones anteriores, no era posible reasignar variables locales referenciadas (\texttt{ref}). Desde C\# 7.2, se permite reasignar estas variables.

\textbf{Solución:} Se modificaron las reglas para permitir la reasignación de variables locales referenciadas.

\subsection{Declaración de Tipos Struct Solo de Lectura (\texttt{readonly struct})}
\textbf{Problema:} En versiones anteriores, no había una forma explícita de declarar estructuras inmutables. Desde C\# 7.2, se introdujo el modificador \texttt{readonly struct} para indicar que una estructura es inmutable y debe pasarse como un parámetro \texttt{in}.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{readonly} en la declaración de estructuras.

\subsection{Modificador \texttt{in} en Parámetros}
\textbf{Problema:} En versiones anteriores, no era posible pasar argumentos por referencia sin permitir su modificación. Desde C\# 7.2, se introdujo el modificador \texttt{in}, que permite pasar argumentos por referencia sin permitir modificaciones.

\textbf{Solución:} Se ajustó la regla \texttt{parameter\_modifier} para incluir el modificador \texttt{in}.

\subsection{Modificador \texttt{ref readonly} en Retornos de Métodos}
\textbf{Problema:} En versiones anteriores, no había una forma explícita de devolver referencias inmutables desde métodos. Desde C\# 7.2, se introdujo el modificador \texttt{ref readonly}, que permite devolver referencias inmutables.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{ref readonly} en las reglas de retorno de métodos.

\subsection{Declaración de Tipos Struct Referenciados (\texttt{ref struct})}
\textbf{Problema:} En versiones anteriores, no había una forma explícita de declarar estructuras que accedan directamente a memoria administrada y deban ser asignadas en el stack. Desde C\# 7.2, se introdujo el modificador \texttt{ref struct}.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{ref struct} en la declaración de estructuras.

\subsection{Más Restricciones Genéricas}
\textbf{Problema:} En versiones anteriores, había limitaciones en las restricciones genéricas. Desde C\# 7.2, se introdujeron más restricciones genéricas para mejorar la flexibilidad.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir más restricciones genéricas.

\subsection{Argumentos Nombrados No Finales}
\textbf{Problema:} En versiones anteriores, los argumentos nombrados debían colocarse al final de la lista de argumentos. Desde C\# 7.2, se permite mezclar argumentos posicionales y nombrados siempre que los posicionales estén primero.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir argumentos nombrados no finales.

\subsection{Guiones Bajos Iniciales en Literales Numéricos}
\textbf{Problema:} En versiones anteriores, los literales numéricos no podían comenzar con guiones bajos (\texttt{\_}). Desde C\# 7.2, se permite usar guiones bajos iniciales antes de los dígitos impresos.

\textbf{Solución:} Se ajustó la gramática para permitir guiones bajos iniciales en literales numéricos.

\subsection{Modificador \texttt{private protected}}
\textbf{Problema:} En versiones anteriores, no había un modificador que combinara las restricciones de acceso \texttt{private} y \texttt{protected}. Desde C\# 7.2, se introdujo el modificador \texttt{private protected}, que permite acceso desde clases derivadas dentro del mismo ensamblado.

\textbf{Solución:} Se agregó soporte para el modificador \texttt{private protected} en las reglas de acceso.

\subsection{Expresiones Condicionales por Referencia}
\textbf{Problema:} En versiones anteriores, las expresiones condicionales (\texttt{?:}) no podían devolver referencias. Desde C\# 7.2, se permite que el resultado sea una referencia.

\textbf{Solución:} Se ajustó la gramática para permitir expresiones condicionales por referencia.


\section{C\# 7.3}

\subsection{Acceso a Campos Fijos Sin Fijación}
\textbf{Problema:} En versiones anteriores de C\#, para acceder a campos fijos era necesario fijar la dirección de memoria. Desde C\# 7.3, se permite acceder a campos fijos sin necesidad de fijarlos explícitamente.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir el acceso a campos fijos sin fijación.

\subsection{Reasignación de Variables Locales Referenciadas}
\textbf{Problema:} En versiones anteriores, no se podía reasignar variables locales referenciadas. Desde C\# 7.3, se permite la reasignación de variables locales que están marcadas como \texttt{ref}.

\textbf{Solución:} Se modificaron las reglas para permitir la reasignación de variables locales referenciadas.

\subsection{Inicializadores en Arreglos Stackalloc}
\textbf{Problema:} En versiones anteriores, no era posible utilizar inicializadores con arreglos creados con \texttt{stackalloc}. Desde C\# 7.3, se permite usar inicializadores en arreglos \texttt{stackalloc}.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir inicializadores en arreglos \texttt{stackalloc}.

\subsection{Sentencias Fijas con Tipos que Soportan Patrones}
\textbf{Problema:} En versiones anteriores, las sentencias fijas solo podían usarse con tipos específicos. Desde C\# 7.3, se permiten sentencias fijas con cualquier tipo que soporte patrones.

\textbf{Solución:} Se modificó la regla \texttt{fixed\_statement} para permitir el uso con cualquier tipo que soporte patrones.

\subsection{Más Restricciones Genéricas}
\textbf{Problema:} En versiones anteriores, había limitaciones en las restricciones genéricas. Desde C\# 7.3, se introdujeron más restricciones genéricas para mejorar la flexibilidad.

\textbf{Solución:} Se ajustaron las reglas gramaticales para permitir más restricciones genéricas.

\subsection{Pruebas con Tipos Tupla}
\textbf{Problema:} En versiones anteriores, no se podía usar \texttt{==} y \texttt{!=} directamente con tipos tupla. Desde C\# 7.3, se permite comparar tuplas usando estos operadores.

\textbf{Solución:} Se modificaron las reglas para permitir comparaciones directas entre tipos tupla.

\subsection{Uso de Variables de Expresión en Más Ubicaciones}
\textbf{Problema:} En versiones anteriores, las variables de expresión tenían un alcance limitado. Desde C\# 7.3, se permite usar variables de expresión en más ubicaciones dentro del código.

\textbf{Solución:} Se ajustaron las reglas gramaticales para ampliar el uso de variables de expresión en diferentes contextos.

\subsection{Atributos en Campos de Respaldo de Propiedades Implementadas Automáticamente}
\textbf{Problema:} En versiones anteriores, no era posible aplicar atributos a los campos de respaldo de propiedades implementadas automáticamente. Desde C\# 7.3, se permite aplicar atributos a estos campos.

\textbf{Solución:} Se modificó la regla \texttt{attribute} para permitir atributos en campos de respaldo.

\subsection{Resolución de Métodos Mejorada al Usar Argumentos Diferentes por \texttt{in}}
\textbf{Problema:} En versiones anteriores, la resolución de métodos al usar argumentos diferentes por \texttt{in} era confusa y poco clara. Desde C\# 7.3, se mejoró este aspecto.

\textbf{Solución:} Se ajustaron las reglas gramaticales para mejorar la resolución de métodos al usar argumentos por \texttt{in}.

\subsection{Resolución de Sobrecargas con Menos Casos Ambiguos}
\textbf{Problema:} En versiones anteriores, había muchos casos ambiguos al resolver sobrecargas de métodos. Desde C\# 7.3, se redujeron los casos ambiguos en la resolución de sobrecargas.

\textbf{Solución:} Se mejoró el algoritmo de resolución en la gramática para reducir ambigüedades.

\section{C\# 8}

\subsection{Miembros Solo de Lectura}
\textbf{Problema:} En versiones anteriores de C\#, no se podía definir miembros de solo lectura en las clases. Desde C\# 8, se introdujeron los miembros solo de lectura, que permiten que las propiedades sean inmutables después de su inicialización.

\textbf{Solución:} Se modificó la regla \texttt{property\_declaration} para permitir miembros solo de lectura.

\subsection{Métodos de Interfaz por Defecto}
\textbf{Problema:} En versiones anteriores de C\#, no era posible definir métodos en interfaces con una implementación por defecto. Desde C\# 8, se introdujeron métodos de interfaz por defecto, permitiendo que las interfaces contengan métodos implementados.

\textbf{Solución:} Se ajustó la regla \texttt{interface\_declaration} para permitir métodos de interfaz con implementación por defecto.

\subsection{Mejoras en Coincidencia de Patrones}
\textbf{Problema:} Las versiones anteriores de C\# tenían limitaciones en los patrones disponibles. Desde C\# 8, se introdujeron mejoras en la coincidencia de patrones, incluyendo expresiones \texttt{switch} y patrones de propiedades.

\textbf{Solución:} Se expandieron las reglas \texttt{pattern} para incluir expresiones \texttt{switch} y patrones mejorados.

\subsection{Patrones de Propiedades}
\textbf{Problema:} En versiones anteriores, no había soporte para patrones que coincidieran con propiedades específicas. Desde C\# 8, se introdujeron patrones de propiedades para facilitar la coincidencia con las propiedades de un objeto.

\textbf{Solución:} Se modificó la regla \texttt{pattern} para incluir patrones que coincidan con propiedades.

\subsection{Patrones Tupla}
\textbf{Problema:} En versiones anteriores, no había soporte para coincidencias basadas en tuplas. Desde C\# 8, se introdujeron patrones tupla para facilitar la coincidencia con estructuras de tuplas.

\textbf{Solución:} Se agregó soporte para patrones tupla en la regla \texttt{pattern}.

\subsection{Patrones Posicionales}
\textbf{Problema:} En versiones anteriores, no había soporte para patrones que coincidieran con la posición de los elementos. Desde C\# 8, se introdujeron patrones posicionales que permiten coincidir elementos en una posición específica.

\textbf{Solución:} Se agregó soporte para patrones posicionales en la regla \texttt{pattern}.

\subsection{Declaraciones Using}
\textbf{Problema:} En versiones anteriores, las declaraciones \texttt{using} debían estar al principio del archivo o dentro del bloque. Desde C\# 8, se permite utilizar declaraciones \texttt{using} dentro del bloque de código.

\textbf{Solución:} Se modificó la regla \texttt{using\_declaration} para permitir declaraciones \texttt{using} más flexibles.

\subsection{Funciones Locales Estáticas}
\textbf{Problema:} Las funciones locales no podían ser estáticas antes. Desde C\# 8, se permite definir funciones locales como estáticas.

\textbf{Solución:} Se agregó soporte para funciones locales estáticas en la gramática.

\subsection{Estructuras Ref Descartables}
\textbf{Problema:} En versiones anteriores, no había un manejo específico para estructuras ref descartables. Desde C\# 8, se introdujo el soporte para estructuras ref descartables que permiten un manejo más eficiente de la memoria.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir estructuras ref descartables.

\subsection{Tipos Nullable Referencia}
\textbf{Problema:} En versiones anteriores, todas las referencias eran consideradas no nulas. Desde C\# 8, se introdujo el concepto de tipos nullable referencia que permite indicar explícitamente si una referencia puede ser nula.

\textbf{Solución:} Se ajustaron las reglas gramaticales para incluir el manejo de tipos nullable referencia.

\subsection{Flujos Asincrónicos}
\textbf{Problema:} En versiones anteriores, no había un manejo eficiente para flujos asincrónicos. Desde C\# 8, se introdujo el soporte para flujos asincrónicos que permite trabajar con secuencias de datos asincrónicas.

\textbf{Solución:} Se modificaron las reglas gramaticales para permitir flujos asincrónicos y su uso en bucles.

\subsection{Índices y Rangos}
\textbf{Problema:} En versiones anteriores, no había una forma sencilla de trabajar con índices y rangos en colecciones. Desde C\# 8, se introdujo el soporte para índices y rangos que facilita el acceso a elementos en colecciones.

\textbf{Solución:} Se agregó soporte para índices y rangos en la gramática.

\subsection{Asignación Null-Coalescing}
\textbf{Problema:} En versiones anteriores, no había una forma concisa de asignar valores cuando una variable es nula. Desde C\# 8, se introdujo el operador null-coalescing assignment (\texttt{??=}).

\textbf{Solución:} Se ajustó la gramática para incluir el operador null-coalescing assignment.

\subsection{Tipos Construidos No Administrados}
\textbf{Problema:} En versiones anteriores, no había un manejo específico para tipos construidos no administrados. Desde C\# 8, se introdujo el soporte para tipos construidos no administrados que permiten trabajar con tipos sin administración del recolector de basura.

\textbf{Solución:} Se agregó soporte para tipos construidos no administrados en la gramática.

\subsection{Stackalloc en Expresiones Anidadas}
\textbf{Problema:} En versiones anteriores, no era posible usar \texttt{stackalloc} dentro de expresiones anidadas. Desde C\# 8, se permite usar \texttt{stackalloc} dentro de expresiones anidadas.

\textbf{Solución:} Se ajustó la gramática para permitir el uso de \texttt{stackalloc} en expresiones anidadas.

\subsection{Mejora en las Cadenas Interpoladas Verbatim}
\textbf{Problema:} Las cadenas interpoladas verbatim tenían limitaciones en su formato. Desde C\# 8, se mejoraron las cadenas interpoladas verbatim para permitir más flexibilidad al incluir expresiones complejas.

\textbf{Solución:} Se modificó la regla \texttt{interpolated\_string\_expression} para mejorar el manejo de cadenas interpoladas verbatim.



\section{C\# 9}

\subsection{Registros}

\textbf{Problema:} En versiones anteriores de C\#, no existía un tipo de datos específico para registros. Sin embargo, desde C\# 9, se introdujeron los registros, que son tipos de referencia inmutables que facilitan la creación de objetos con propiedades.

\textbf{Solución:} Se modificó la regla \texttt{class\_declaration} para permitir la definición de registros.

\subsection{Setters Solo de Inicialización}

\textbf{Problema:} En versiones anteriores de C\#, todas las propiedades podían ser modificadas después de su inicialización. Desde C\# 9, se introdujo la posibilidad de definir propiedades con setters solo de inicialización, permitiendo que las propiedades sean asignadas solo durante la creación del objeto.

\textbf{Solución:} Se ajustó la regla \texttt{property\_declaration} para incluir el modificador \texttt{init}.

\subsection{Declaraciones en Nivel Superior}

\textbf{Problema:} En versiones anteriores de C\#, el código debía estar contenido dentro de una clase o espacio de nombres. Desde C\# 9, se permite escribir declaraciones en nivel superior, lo que simplifica el código.

\textbf{Solución:} Se modificó la gramática para permitir declaraciones en nivel superior sin necesidad de definir una clase.

\subsection{Mejoras en Coincidencia de Patrones}

\textbf{Problema:} Las versiones anteriores de C\# tenían limitaciones en los patrones disponibles. Desde C\# 9, se introdujeron mejoras en la coincidencia de patrones, incluyendo patrones relacionales y lógicos.

\textbf{Solución:} Se expandieron las reglas \texttt{pattern} para incluir patrones relacionales y lógicos.

\subsection{Rendimiento e Interoperabilidad}

\textbf{Problema:} En versiones anteriores, las optimizaciones para el rendimiento y la interoperabilidad eran limitadas. Desde C\# 9, se han realizado mejoras significativas en estas áreas.

\textbf{Solución:} Se implementaron mejoras en el manejo del rendimiento y la interoperabilidad a través de ajustes en las reglas gramaticales y optimizaciones internas.

\subsection{Enteros de Tamaño Nativo}

\textbf{Problema:} En versiones anteriores de C\#, no había un tipo específico para enteros que se adaptara al tamaño nativo del sistema. Desde C\# 9, se introdujeron enteros de tamaño nativo (\texttt{nint} y \texttt{nuint}).

\textbf{Solución:} Se agregó soporte para los tipos \texttt{nint} y \texttt{nuint} en la regla \texttt{type\_}.

\subsection{Punteros a Funciones}

\textbf{Problema:} En versiones anteriores de C\#, no era posible trabajar con punteros a funciones directamente. Desde C\# 9, se introdujo el soporte para punteros a funciones.

\textbf{Solución:} Se agregó soporte para punteros a funciones en las reglas correspondientes.

\subsection{Suprimir el Emisión del Flag \texttt{localsinit}}

\textbf{Problema:} En versiones anteriores, cada método emitía automáticamente un flag \texttt{localsinit}, lo que podía afectar el rendimiento. Desde C\# 9, se permite suprimir este flag.

\textbf{Solución:} Se ajustaron las reglas para permitir la supresión del flag \texttt{localsinit}.

\subsection{Inicializadores de Módulo}

\textbf{Problema:} En versiones anteriores, no había una forma específica de inicializar módulos. Desde C\# 9, se introdujeron inicializadores de módulo.

\textbf{Solución:} Se agregó soporte para inicializadores de módulo en la gramática.

\subsection{Nuevas Funciones para Métodos Parciales}

\textbf{Problema:} Las funciones parciales tenían limitaciones en su uso. Desde C\# 9, se introdujeron nuevas características para métodos parciales.

\textbf{Solución:} Se ajustaron las reglas relacionadas con métodos parciales para incluir nuevas características.

\subsection{Características de Ajuste y Terminación}

\textbf{Problema:} Las versiones anteriores carecían de ciertas características estéticas y funcionales. Desde C\# 9, se mejoraron varios aspectos visuales y funcionales del lenguaje.

\textbf{Solución:} Se realizaron ajustes generales en la gramática y el formato del lenguaje.

\subsection{Expresiones Nuevas con Tipos Objetivo}

\textbf{Problema:} Antes de C\# 9, no había una forma concisa de crear instancias utilizando tipos objetivo. Desde esta versión, se permite crear expresiones tipadas directamente.

\textbf{Solución:} Se ajustó la gramática para permitir expresiones tipadas al usar \texttt{new}.

\subsection{Funciones Anónimas Estáticas}

\textbf{Problema:} Las funciones anónimas no podían ser estáticas anteriormente. Sin embargo, desde C\# 9, se permite definir funciones anónimas como estáticas.

\textbf{Solución:} Se agregó soporte para funciones anónimas estáticas en la gramática.

\subsection{Expresiones Condicionales Tipadas por Objetivo}

\textbf{Problema:} Las expresiones condicionales no podían ser tipadas por objetivo antes. Desde C\# 9, se permite que las expresiones condicionales tengan un tipo objetivo inferido.

\textbf{Solución:} Se modificó la gramática para permitir expresiones condicionales tipadas por objetivo.

\subsection{Tipos Retornados Covariantes}

\textbf{Problema:} En versiones anteriores, los tipos retornados covariantes no eran compatibles. Sin embargo, desde C\# 9, se introdujo el soporte para tipos retornados covariantes en métodos virtuales o sobrescritos.

\textbf{Solución:} Se ajustó la regla \texttt{method\_declaration} para permitir tipos retornados covariantes.

\subsection{Soporte para Extensiones GetEnumerator en Bucles \texttt{foreach}}

\textbf{Problema:} Antes de C\# 9, el bucle \texttt{foreach} requería que las colecciones implementaran explícitamente \texttt{IEnumerable}. Con esta versión, se permite un soporte más flexible mediante extensiones \texttt{GetEnumerator}.

\textbf{Solución:} Se modificó la regla correspondiente al bucle \texttt{foreach} para incluir soporte para extensiones \texttt{GetEnumerator}.

\subsection{Parámetros Descartados en Lambdas}

\textbf{Problema:} En versiones anteriores, los parámetros descartados no eran compatibles en expresiones lambda. Sin embargo, desde C\# 9, se permite usar parámetros descartados (\texttt{\_}) en lambdas.

\textbf{Solución:} Se ajustó la regla \texttt{lambda\_expression} para permitir parámetros descartados.

\subsection{Atributos en Funciones Locales}

\textbf{Problema:} Anteriormente no era posible aplicar atributos a funciones locales. Sin embargo, desde C\# 9, se permite aplicar atributos a funciones locales definidas dentro de métodos.

\textbf{Solución:} Se modificó la regla correspondiente a los atributos para permitir su uso en funciones locales.

\section{C\# 10}

\subsection{Estructuras de Registro}
\textbf{Problema:} En versiones anteriores de C\#, las estructuras de registro no estaban disponibles. Sin embargo, desde C\# 10, se introdujeron las estructuras de registro, que permiten definir estructuras con características de registro.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir estructuras de registro.

\subsection{Mejoras en Tipos de Estructura}
\textbf{Problema:} En versiones anteriores de C\#, los tipos de estructura no tenían tantas características como las clases. Sin embargo, desde C\# 10, se mejoraron los tipos de estructura para que puedan incluir más funcionalidades.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir más características en estructuras.

\subsection{Manejadores de Cadenas Interpoladas}
\textbf{Problema:} En versiones anteriores de C\#, no había una forma explícita de manejar las cadenas interpoladas. Sin embargo, desde C\# 10, se introdujeron los manejadores de cadenas interpoladas para mejorar su manejo.

\textbf{Solución:} Se ajustó la regla \texttt{interpolated\_string\_expression} para reconocer correctamente las expresiones dentro de cadenas interpoladas.

\subsection{Directivas \texttt{using} Globales}
\textbf{Problema:} En versiones anteriores de C\#, las directivas \texttt{using} debían estar dentro de un espacio de nombres. Sin embargo, desde C\# 10, se permiten directivas \texttt{using} globales que pueden aplicarse a todo el archivo.

\textbf{Solución:} Se modificó la regla \texttt{using\_directive} para permitir directivas \texttt{using} globales.

\subsection{Declaración de Espacios de Nombres a Nivel de Archivo}
\textbf{Problema:} En versiones anteriores de C\#, los espacios de nombres debían declararse utilizando llaves (\texttt{\{\}}). Sin embargo, desde C\# 10, también es posible declararlos con punto y coma (\texttt{;}), permitiendo definiciones más concisas.

\textbf{Solución:} Se amplió la regla \texttt{namespace\_declaration} para soportar ambas sintaxis.

\subsection{Patrones de Propiedades Extendidos}
\textbf{Problema:} En versiones anteriores de C\#, los patrones de propiedades no eran tan flexibles. Sin embargo, desde C\# 10, se extendieron los patrones de propiedades para permitir más flexibilidad en la coincidencia de patrones.

\textbf{Solución:} Se modificó la regla \texttt{pattern} para soportar patrones de propiedades extendidos.

\subsection{Expresiones Lambda con Tipo Natural}
\textbf{Problema:} En versiones anteriores de C\#, las expresiones lambda debían tener un tipo explícito. Sin embargo, desde C\# 10, se permite que las expresiones lambda tengan un tipo natural, donde el compilador puede inferir el tipo delegado.

\textbf{Solución:} Se modificó la regla \texttt{lambda\_expression} para permitir tipos naturales en expresiones lambda.

\subsection{Expresiones Lambda con Tipo de Retorno Explícito}
\textbf{Problema:} En versiones anteriores de C\#, las expresiones lambda no podían declarar un tipo de retorno explícito. Sin embargo, desde C\# 10, se permite que las expresiones lambda declaren un tipo de retorno cuando el compilador no puede inferirlo.

\textbf{Solución:} Se modificó la regla \texttt{lambda\_expression} para permitir tipos de retorno explícitos.

\subsection{Atributos en Expresiones Lambda}
\textbf{Problema:} En versiones anteriores de C\#, los atributos no podían aplicarse a expresiones lambda. Sin embargo, desde C\# 10, se permite aplicar atributos a expresiones lambda.

\textbf{Solución:} Se modificó la regla \texttt{lambda\_expression} para permitir atributos.

\subsection{Inicialización de Cadenas Constantes con Interpolación}
\textbf{Problema:} En versiones anteriores de C\#, las cadenas constantes no podían inicializarse con interpolación. Sin embargo, desde C\# 10, se permite inicializar cadenas constantes utilizando interpolación si todos los marcadores son cadenas constantes.

\textbf{Solución:} Se ajustó la regla \texttt{constant\_expression} para permitir interpolación en cadenas constantes.

\subsection{Modificador \texttt{sealed} en \texttt{ToString} de Registros}
\textbf{Problema:} En versiones anteriores de C\#, no había una forma explícita de sellar el método \texttt{ToString} en tipos de registro. Sin embargo, desde C\# 10, se permite agregar el modificador \texttt{sealed} cuando se sobrescribe \texttt{ToString} en un tipo de registro.

\textbf{Solución:} Se modificó la regla \texttt{method\_declaration} para permitir el modificador \texttt{sealed} en \texttt{ToString}.

\subsection{Advertencias para Asignación Definida y Análisis de Estado Nulo}
\textbf{Problema:} En versiones anteriores de C\#, las advertencias para asignación definida y análisis de estado nulo no eran tan precisas. Sin embargo, desde C\# 10, se mejoraron estas advertencias para ser más precisas.

\textbf{Solución:} Se ajustó la regla \texttt{expression} para mejorar las advertencias relacionadas con la asignación definida y el análisis de estado nulo.

\subsection{Declaración y Asignación en Deconstrucción}
\textbf{Problema:} En versiones anteriores de C\#, la deconstrucción solo permitía declarar variables. Sin embargo, desde C\# 10, se permite tanto declarar como asignar valores en la misma deconstrucción.

\textbf{Solución:} Se modificó la regla \texttt{deconstruction\_expression} para permitir tanto declaraciones como asignaciones.

\subsection{Atributo \texttt{AsyncMethodBuilder}}
\textbf{Problema:} En versiones anteriores de C\#, no había una forma explícita de marcar métodos como constructores de métodos asíncronos. Sin embargo, desde C\# 10, se introdujo el atributo \texttt{AsyncMethodBuilder} para indicar métodos que construyen métodos asíncronos.

\textbf{Solución:} Se agregó soporte para el atributo \texttt{AsyncMethodBuilder}.

\subsection{Atributo \texttt{CallerArgumentExpression}}
\textbf{Problema:} En versiones anteriores de C\#, no había una forma explícita de obtener la expresión del argumento del llamador. Sin embargo, desde C\# 10, se introdujo el atributo \texttt{CallerArgumentExpression} para obtener esta información.

\textbf{Solución:} Se agregó soporte para el atributo \texttt{CallerArgumentExpression}.

\subsection{Nuevo Formato para la Directiva \texttt{\#line}}
\textbf{Problema:} En versiones anteriores de C\#, la directiva \texttt{\#line} no tenía un formato flexible. Sin embargo, desde C\# 10, se introdujo un nuevo formato para esta directiva que permite más flexibilidad.

\textbf{Solución:} Se modificó la regla \texttt{line\_directive} para soportar el nuevo formato.


\section{C\# 11}

\subsection{Literales de Cadena Raw}

\textbf{Problema:} En versiones anteriores de C\#, las cadenas literales no podían contener caracteres especiales sin escaparlos. Sin embargo, desde C\# 11, se introdujeron los literales de cadena raw, que permiten cadenas sin necesidad de escapar caracteres especiales.

\textbf{Solución:} Se agregó soporte para los literales de cadena raw en la regla \texttt{string\_literal}.

\subsection{Soporte Genérico para Operaciones Matemáticas}

\textbf{Problema:} En versiones anteriores de C\#, las operaciones matemáticas no podían ser genéricas. Sin embargo, desde C\# 11, se introdujo el soporte genérico para operaciones matemáticas, permitiendo definir métodos que trabajen con tipos numéricos genéricos.

\textbf{Solución:} Se modificó la regla \texttt{type\_} para permitir tipos genéricos en operaciones matemáticas.

\subsection{Atributos Genéricos}

\textbf{Problema:} En versiones anteriores de C\#, los atributos no podían ser genéricos. Sin embargo, desde C\# 11, se introdujo el soporte para atributos genéricos, permitiendo definir atributos que acepten tipos genéricos.

\textbf{Solución:} Se modificó la regla \texttt{attribute} para permitir atributos genéricos.

\subsection{Literales de Cadena UTF-8}

\textbf{Problema:} En versiones anteriores de C\#, las cadenas literales no podían especificar codificación UTF-8 explícitamente. Sin embargo, desde C\# 11, se introdujo el soporte para literales de cadena UTF-8, permitiendo especificar la codificación explícitamente.

\textbf{Solución:} Se agregó soporte para literales de cadena UTF-8 en la regla \texttt{string\_literal}.

\subsection{Saltos de Línea en Expresiones Interpoladas}

\textbf{Problema:} En versiones anteriores de C\#, las expresiones interpoladas no permitían saltos de línea dentro de la cadena. Sin embargo, desde C\# 11, se permite incluir saltos de línea en expresiones interpoladas.

\textbf{Solución:} Se modificó la regla \texttt{interpolated\_string\_expression} para permitir saltos de línea.

\subsection{Patrones de Lista}

\textbf{Problema:} En versiones anteriores de C\#, los patrones no podían aplicarse a listas. Sin embargo, desde C\# 11, se introdujo el soporte para patrones de lista, permitiendo comparar listas con patrones específicos.

\textbf{Solución:} Se agregó soporte para patrones de lista en la regla \texttt{pattern}.

\subsection{Tipos Locales a Archivo}

\textbf{Problema:} En versiones anteriores de C\#, los tipos definidos debían ser accesibles desde cualquier parte del archivo. Sin embargo, desde C\# 11, se introdujo el soporte para tipos locales a archivo, permitiendo definir tipos que solo sean accesibles dentro del mismo archivo.

\textbf{Solución:} Se modificó la regla \texttt{class\_definition} para permitir tipos locales a archivo.

\subsection{Miembros Obligatorios}

\textbf{Problema:} En versiones anteriores de C\#, no había una forma explícita de marcar miembros como obligatorios. Sin embargo, desde C\# 11, se introdujo el soporte para miembros obligatorios, permitiendo definir miembros que deben ser inicializados.

\textbf{Solución:} Se agregó soporte para miembros obligatorios en la regla \texttt{property\_declaration}.

\subsection{Estructuras con Valores Predeterminados}

\textbf{Problema:} En versiones anteriores de C\#, las estructuras no tenían valores predeterminados. Sin embargo, desde C\# 11, se introdujo el soporte para estructuras con valores predeterminados, permitiendo que las estructuras tengan valores por defecto.

\textbf{Solución:} Se modificó la regla \texttt{struct\_declaration} para permitir valores predeterminados en estructuras.

\subsection{Coincidencia de Patrones con \texttt{Span\textless char\textgreater}}

\textbf{Problema:} En versiones anteriores de C\#, los patrones no podían aplicarse a \texttt{Span\textless char\textgreater}. Sin embargo, desde C\# 11, se introdujo el soporte para coincidir patrones con \texttt{Span\textless char\textgreater}.

\textbf{Solución:} Se agregó soporte para patrones con \texttt{Span\textless char\textgreater} en la regla \texttt{pattern}.

\subsection{Alcance Extendido de \texttt{nameof}}

\textbf{Problema:} En versiones anteriores de C\#, el operador \texttt{nameof} solo podía aplicarse a nombres de tipos y miembros. Sin embargo, desde C\# 11, se extendió el alcance de \texttt{nameof} para permitir su uso en más contextos.

\textbf{Solución:} Se modificó la regla \texttt{expression} para permitir el uso extendido de \texttt{nameof}.

\subsection{Tipo \texttt{IntPtr} Numérico}

\textbf{Problema:} En versiones anteriores de C\#, el tipo \texttt{IntPtr} no era numérico. Sin embargo, desde C\# 11, se introdujo el soporte para que \texttt{IntPtr} sea un tipo numérico.

\textbf{Solución:} Se modificó la regla \texttt{type\_} para permitir que \texttt{IntPtr} sea un tipo numérico.

\subsection{Campos \texttt{ref} y \texttt{scoped ref}}

\textbf{Problema:} En versiones anteriores de C\#, los campos no podían ser \texttt{ref}. Sin embargo, desde C\# 11, se introdujo el soporte para campos \texttt{ref} y \texttt{scoped ref}, permitiendo definir campos que se comporten como referencias.

\textbf{Solución:} Se agregó soporte para campos \texttt{ref} en la regla \texttt{field\_declaration}.

\subsection{Mejora en la Conversión de Grupos de Métodos a Delegados}

\textbf{Problema:} En versiones anteriores de C\#, la conversión de grupos de métodos a delegados no era tan flexible. Sin embargo, desde C\# 11, se mejoró esta conversión para permitir más flexibilidad en la asignación de métodos a delegados.

\textbf{Solución:} Se modificó la regla \texttt{expression} para mejorar la conversión de grupos de métodos a delegados.

\subsection{Ola de Advertencias 7}

\textbf{Problema:} En versiones anteriores de C\#, no había una forma explícita de marcar características experimentales. Sin embargo, desde C\# 11, se introdujo la ola de advertencias 7 para indicar características experimentales.

\textbf{Solución:} Se agregó soporte para la ola de advertencias 7 en la regla \texttt{attribute}.


\section{C\# 12}

\subsection{Constructores Primarios}

\textbf{Problema:} En versiones anteriores de C\#, los constructores deb\'ian definirse expl\'icitamente dentro de una clase o estructura. Desde C\# 12, se permite crear constructores primarios en cualquier tipo de clase o estructura.

\textbf{Soluci\'on:} Se modific\'o la regla \texttt{class\_definition} para permitir constructores primarios. Esto simplifica la definici\'on de clases y estructuras al combinar la declaraci\'on de par\'ametros con la inicializaci\'on de campos.

\subsection{Expresiones de Colecci\'on}

\textbf{Problema:} En versiones anteriores de C\#, las colecciones se creaban utilizando el operador \texttt{new[]}. Desde C\# 12, se introdujo una nueva sintaxis para expresiones de colecci\'on, incluyendo el elemento de propagaci\'on (\texttt{..e}).

\textbf{Soluci\'on:} Se agreg\'o una nueva regla para soportar las expresiones de colecci\'on, definiendo la sintaxis de colecciones en l\'inea y el operador de propagaci\'on (\texttt{..e}).

\subsection{Arrays en L\'inea}

\textbf{Problema:} En versiones anteriores de C\#, los arrays deb\'ian declararse con un tama\~no fijo utilizando llaves (\texttt{\{}). Desde C\# 12, se permite declarar arrays en l\'inea dentro de estructuras.

\textbf{Soluci\'on:} Se modific\'o la regla \texttt{type\_} para permitir arrays en l\'inea, simplificando la declaraci\'on de estructuras con arrays de tama\~no fijo.

\subsection{Par\'ametros Opcionales en Expresiones Lambda}

\textbf{Problema:} En versiones anteriores de C\#, los par\'ametros en expresiones lambda no pod\'ian ser opcionales. Desde C\# 12, se permite el uso de par\'ametros opcionales en expresiones lambda.

\textbf{Soluci\'on:} Se actualiz\'o la regla \texttt{explicit\_anonymous\_function\_parameter} para soportar par\'ametros opcionales.

\subsection{Par\'ametros \texttt{ref readonly}}

\textbf{Problema:} En versiones anteriores de C\#, los par\'ametros en expresiones lambda no pod\'ian ser \texttt{ref readonly}. Desde C\# 12, se permite el uso de par\'ametros \texttt{ref readonly} en expresiones lambda.

\textbf{Soluci\'on:} Se modific\'o la regla \texttt{explicit\_anonymous\_function\_parameter} para soportar par\'ametros \texttt{ref readonly}.

\subsection{Alias Any Type}

\textbf{Problema:} En versiones anteriores de C\#, el alias de tipo solo se pod\'ia utilizar con tipos nombrados. Desde C\# 12, se permite utilizar el alias de tipo con cualquier tipo.

\textbf{Soluci\'on:} Se actualiz\'o la regla \texttt{using\_directive} para permitir alias de cualquier tipo.

\subsection{Atributo Experimental}

\textbf{Problema:} En versiones anteriores de C\#, no hab\'ia una forma expl\'icita de marcar caracter\'isticas experimentales. Desde C\# 12, se introdujo el atributo \texttt{Experimental}.

\textbf{Soluci\'on:} Se agreg\'o soporte para el atributo \texttt{Experimental}.


\chapter{Extracción de features del AST}\label{chapter:proposal}

\section{Extraccion del AST}

 Se emplea ANTLR para extraer Árboles de Sintaxis Abstracta (AST) a partir del código fuente de programas escritos en C\#. Convierte una gramática de lenguaje en código que puede generar un árbol de sintaxis. \\
 A continuación, se explica su funcionamiento y las etapas principales en su flujo de trabajo:
 
 \begin{enumerate}
    \item \textbf{Definición de la Gramática:}
    Primero, se define la gramática del lenguaje en un archivo \texttt{.g4}. Este archivo incluye:
    \begin{itemize}
        \item \textbf{Reglas léxicas (tokens):} especifican los elementos más básicos, como palabras clave, identificadores, operadores, números, etc.
        \item \textbf{Reglas sintácticas:} describen cómo se combinan los tokens para formar sentencias válidas en el lenguaje.
    \end{itemize}
    Cada regla léxica o sintáctica tiene un nombre y una expresión que define qué secuencias de caracteres o estructuras pueden corresponderse con esa regla.

    \item \textbf{Generación del Lexer y el Parser:}
    ANTLR toma el archivo de gramática \texttt{.g4} y genera clases en un lenguaje de programación (como Java, Python, C\#, etc.) que implementan el lexer (analizador léxico) y el parser (analizador sintáctico).
    \begin{itemize}
        \item \textbf{Lexer:} identifica tokens en el texto de entrada. Por ejemplo, en una expresión matemática, reconoce números, operadores, paréntesis, etc.
        \item \textbf{Parser:} usa estos tokens para construir una estructura jerárquica que representa la gramática definida, lo cual permite reconocer la estructura completa del código o texto de entrada.
    \end{itemize}

    \item \textbf{Análisis del Código o Texto de Entrada:} Con el lexer y parser generados, se puede analizar el código fuente. Este proceso produce un árbol de sintaxis que representa la estructura jerárquica del código según la gramática.

    \item \textbf{Creación del Árbol de Sintaxis Abstracta (AST):} ANTLR facilita la creación de un AST, una representación simplificada que retiene la estructura lógica del código, omitiendo detalles innecesarios para ciertos tipos de análisis.

    \item \textbf{Recorridos y Transformaciones en el AST:} Una vez construido el AST, es posible recorrerlo para realizar análisis adicionales, transformaciones o para interpretar el código. ANTLR proporciona métodos para recorrer este árbol y manipular los nodos según las reglas definidas en la gramática, en este caso se utilizó el listener llamado {\bf CSharpParserListener}, proporcionado por ANTLR para recorrer el árbol y extraer los features.
\end{enumerate}



\section{Extraccion de features}

En el análisis de similitud de código y detección de patrones, es necesario extraer características relevantes que capturen la estructura y el comportamiento del código. Estas características, conocidas como {\bf features}, representan los aspectos más importantes de los datos, permitiendo analizar y comparar fragmentos de código de manera efectiva. Para este propósito, se implementó una clase llamada {\bf FeatureExtractorListener}, que extiende la funcionalidad de CSharpParserListener para analizar el código fuente en C\#. A continuación, se presenta una descripción detallada del proceso de extracción de características y la importancia de cada una. \\

\begin{enumerate}
	\item Estructura del AST:
    		\begin{itemize}
			\item {\bf total\_nodes:} Número total de nodos en el AST.
			\item {\bf max\_depth:} Profundidad máxima del AST.
		\end{itemize}
		
	 \item Declaraciones y Variables:
    \begin{itemize}
        \item {\bf variables:} Número de variables locales.
        \item {\bf constants:} Número de constantes declaradas.
        \item {\bf variable\_names:} Conjunto de nombres de variables y sus tipos.
        \item {\bf number\_of\_tuples:} Número de variables de tipo tupla.
        \item {\bf lists:} Número de listas declaradas.
        \item {\bf dicts:} Número de diccionarios declarados.
    \end{itemize}
    
Las variables y constantes son elementos clave en cualquier programa, ya que almacenan y mantienen valores que pueden cambiar o permanecer fijos durante la ejecución. Comprender el uso de estas entidades en el código permite analizar cómo se manipulan los datos, identificar el flujo de información y observar cómo evolucionan los valores a lo largo del programa. Las variables revelan el comportamiento dinámico del código, mientras que las constantes indican valores fijos que definen parámetros o condiciones estables dentro del flujo de ejecución.\\

Además, la variedad y el tipo de estructuras de datos empleadas, como tuplas, listas y diccionarios, aportan información importante sobre el enfoque y la complejidad del código. Por ejemplo, el uso de estructuras de datos más avanzadas, como diccionarios anidados o listas de objetos, puede reflejar una mayor abstracción y modularidad en el diseño, mientras que estructuras más simples pueden indicar un código directo y menos complejo. Estas elecciones también proporcionan información sobre el estilo de programación del autor y sus preferencias en cuanto a la organización y manipulación de datos.

    \item Declaraciones de Métodos y Clases:
    \begin{itemize}
        \item {\bf methods:} Número de métodos declarados.
        \item {\bf method\_names:} Conjunto de nombres de métodos.
        \item {\bf method\_return\_types:} Conjunto de tipos de retorno de métodos.
        \item {\bf method\_parameters:} Lista de parámetros de métodos.
        \item {\bf classes:} Número de clases declaradas.
        \item {\bf class\_names:} Conjunto de nombres de clases.
        \item {\bf abstract\_classes:} Número de clases abstractas.
        \item {\bf sealed\_classes:} Número de clases selladas.
        \item {\bf interfaces:} Número de interfaces declaradas.
        \item {\bf interface\_names:} Conjunto de nombres de interfaces.
    \end{itemize}
    
    La estructura y los nombres de los métodos y clases ofrecen información clave sobre la organización, modularidad y legibilidad del código. Los nombres de métodos y clases, cuando están bien definidos y siguen convenciones de nomenclatura clara, actúan como una especie de documentación implícita, ayudando a comprender la función y el propósito de cada componente sin necesidad de examinar cada detalle interno. 

Los métodos y sus parámetros son esenciales para entender la funcionalidad del código. Los métodos representan acciones específicas y los parámetros definen los datos con los que esas acciones trabajan. Al analizar los métodos y los tipos de parámetros que aceptan, se puede deducir cómo las distintas partes del código interactúan y colaboran para realizar tareas. La estructura de los métodos, su nivel de abstracción, y la forma en que interactúan con otros componentes del código revelan la profundidad de la modularidad y el diseño de la aplicación, lo que facilita el análisis de patrones y la identificación de similitudes entre diferentes fragmentos de código.

Por otro lado, las clases y sus tipos (como clases abstractas o selladas) indican la arquitectura y el paradigma de diseño de la aplicación. Las clases abstractas, por ejemplo, representan conceptos generales que definen una estructura básica sin implementación completa, alentando la reutilización y la extensibilidad en el diseño del sistema. Las clases selladas (sealed) limitan la herencia, sugiriendo un diseño más controlado y dirigido a la especificidad. Estas elecciones de diseño reflejan la intención del desarrollador en cuanto a la extensibilidad, la reutilización y la encapsulación, todos ellos principios fundamentales en la programación orientada a objetos.

    \item Estructuras de Control:
    \begin{itemize}
        \item {\bf control\_structures\_if:} Número de sentencias if.
        \item {\bf control\_structures\_switch:} Número de sentencias switch.
        \item {\bf control\_structures\_for:} Número de bucles for.
        \item {\bf control\_structures\_while:} Número de bucles while.
        \item {\bf control\_structures\_dowhile:} Número de bucles do-while.
        \item {\bf try\_catch\_blocks:} Número de bloques try-catch.
    \end{itemize}
    
    Las estructuras de control son fundamentales para comprender el flujo del programa y su lógica. Un mayor número de estructuras de control indica una lógica más compleja y ramificada.

    \item Modificadores y Accesibilidad:
    \begin{itemize}
        \item {\bf access\_modifiers\_public:} Número de elementos públicos.
        \item {\bf access\_modifiers\_private:} Número de elementos privados.
        \item {\bf access\_modifiers\_protected:} Número de elementos protegidos.
        \item {\bf access\_modifiers\_internal:} Número de elementos internos.
        \item {\bf access\_modifiers\_static:} Número de elementos estáticos.
        \item {\bf access\_modifiers\_protected\_internal:} Número de elementos protegidos internos.
        \item {\bf access\_modifiers\_private\_protected:} Número de elementos privados protegidos.
    \end{itemize}
    Los modificadores de acceso proporcionan información sobre la encapsulación y visibilidad de los componentes del código. La prevalencia de ciertos modificadores puede indicar prácticas de diseño y seguridad en el código.

    \item Modificadores Específicos:
    \begin{itemize}
        \item {\bf modifier\_readonly:} Número de elementos readonly.
        \item {\bf modifier\_volatile:} Número de elementos volatile.
        \item {\bf modifier\_virtual:} Número de elementos virtual.
        \item {\bf modifier\_override:} Número de elementos override.
        \item {\bf modifier\_new:} Número de elementos new.
        \item {\bf modifier\_partial:} Número de elementos partial.
        \item {\bf modifier\_extern:} Número de elementos extern.
        \item {\bf modifier\_unsafe:} Número de elementos unsafe.
        \item {\bf modifier\_async:} Número de elementos async.
    \end{itemize}
    
    Estos modificadores específicos reflejan patrones de diseño, control y comportamiento que van más allá de la simple estructura superficial del código. Al analizar modificadores como readonly, volatile o async, se capturan detalles sobre cómo el código maneja la concurrencia, la inmutabilidad y la asincronía, se utilizan para identificar similitudes en la lógica y el flujo de ejecución. Modificadores como virtual y override indican una arquitectura orientada a objetos, esto permite comparar el grado de extensibilidad y personalización en diferentes fragmentos de código. Además, la presencia de unsafe y extern sugiere que el código interactúa con recursos de bajo nivel o externos, lo que proporciona información sobre la complejidad y las dependencias de cada implementación.\\

    \item Llamadas a Librerías y LINQ(Language Integrated Query):
    \begin{itemize}
        \item {\bf library\_call\_console:} Número de llamadas a la librería Console.
        \item {\bf library\_call\_math:} Número de llamadas a la librería Math.
        \item {\bf linq\_queries\_select:} Número de consultas LINQ Select.
        \item {\bf linq\_queries\_where:} Número de consultas LINQ Where.
        \item {\bf linq\_queries\_orderBy:} Número de consultas LINQ OrderBy.
        \item {\bf linq\_queries\_groupBy:} Número de consultas LINQ GroupBy.
        \item {\bf linq\_queries\_join:} Número de consultas LINQ Join.
        \item {\bf linq\_queries\_sum:} Número de consultas LINQ Sum.
        \item {\bf linq\_queries\_count:} Número de consultas LINQ Count.
    \end{itemize}
    
    Las llamadas a librerías y las consultas LINQ ofrecen información sobre cómo el código aprovecha las funcionalidades estándar y gestiona la manipulación de datos. Al utilizar llamadas a librerías, el código accede a un conjunto de herramientas predefinidas y optimizadas. Esto permite deducir la experiencia y el estilo del programador en términos de modularidad y adaptabilidad, aspectos clave en la estructura y lógica del código.\\

Por otro lado, el uso de consultas LINQ para manipular y consultar colecciones de datos refleja un enfoque específico en la optimización y claridad de la manipulación de datos en .NET. LINQ permite un acceso eficiente a estructuras de datos complejas, proporcionando una sintaxis uniforme para realizar operaciones como filtrado, proyección, agrupación y ordenación. La presencia de consultas LINQ en el código puede indicar la preferencia del desarrollador por una sintaxis declarativa y una gestión avanzada de colecciones, que resulta fundamental para identificar similitudes en la forma en que diferentes fragmentos de código manejan datos.

    \item Otras Características:
    \begin{itemize}
        \item {\bf number\_of\_lambdas:} Número de expresiones lambda.
        \item {\bf number\_of\_getters:} Número de métodos get.
        \item {\bf number\_of\_setters:} Número de métodos set.
        \item {\bf number\_of\_namespaces:} Número de espacios de nombres.
        \item {\bf enums:} Número de enumeraciones.
        \item {\bf enum\_names:} Conjunto de nombres de enumeraciones.
        \item {\bf delegates:} Número de delegados.
        \item {\bf delegate\_names:} Conjunto de nombres de delegados.
        \item {\bf node\_count:} Conteo de nodos por tipo.
    \end{itemize}
    Estas características adicionales permiten analizar el código desde distintas perspectivas que revelan aspectos de diseño y organización. Por ejemplo, el número de expresiones lambda indica la frecuencia de uso de funciones anónimas, lo cual puede reflejar una orientación hacia la programación funcional. La cantidad de métodos de acceso ofrece una idea del manejo de encapsulamiento y control de atributos en las clases. La presencia de espacios de nombres sugiere la estructura modular del código y la separación de responsabilidades, lo que facilita la organización y evita conflictos de nombres. Las enumeraciones y los delegados muestran la variedad de estructuras y tipos personalizados utilizados. Finalmente, el conteo de nodos por tipo permite una visión detallada de los elementos específicos del árbol de sintaxis abstracta, lo cual es útil para evaluar la complejidad y el tipo de construcciones empleadas.
 
\end{enumerate}
    
        
La extracción de características con FeatureExtractorListener permite capturar aspectos relevantes del código fuente en C\#, desde su estructura y complejidad hasta los patrones de diseño y las prácticas de programación. La implementación y el análisis detallado de estas características proporcionan una base sólida para mejorar la precisión de las herramientas de análisis de código.



\chapter{Preparacion del dataset}\label{chapter:proposal}

Para preparar el dataset, se convierten los nombres de variables, métodos y otros identificadores de tipo string en vectores de características numéricas, lo cual permite que un modelo de machine learning procese el código de manera efectiva. Este proceso de transformación se realiza utilizando embeddings, una técnica de procesamiento del lenguaje natural, mediante el modelo Word2Vec \cite{mikolov2013efficient}. Estos embeddings se combinan con otras características numéricas extraídas del código, como el número de métodos o la cantidad de expresiones lambda, lo cual forma un vector de características completo. Este vector integrado proporciona una descripción multidimensional del código, capturando tanto la estructura como la semántica en una única representación, lo que mejora la capacidad del modelo para detectar patrones y realizar comparaciones entre diferentes fragmentos de código.

\section{Construcción del dataset}

El dataset de códigos en C\# está compuesto por pares de archivos que mantienen la misma funcionalidad pero presentan variaciones en la estructura y nomenclatura. Cada par está compuesto por un archivo original y su respectiva copia, con cambios mínimos y modificaciones que buscan simular escenarios típicos en los que el código mantiene su esencia lógica pero experimenta alteraciones en la sintaxis y organización, abarcan desde algoritmos fundamentales de programación hasta aplicaciones prácticas en la vida diaria.

 Se eligieron las principales inteligencias artificiales generativas mas utilizados para la generación de código pues cuenta con 300 archivos generados por ChatGPT, 300 por Copilot, 150 con Perplexity y 90 con Phind donde la mitad son originales y la mitad son copias, teniendo un total de 1000 códigos. 

\begin{enumerate}
    \item \textbf{Creación de Código Base}: Se crearon múltiples fragmentos de código en C\# que abarcan una variedad de funciones comunes, como cálculos geométricos, operaciones matemáticas, manipulación de cadenas de texto y validaciones de números. Estos fragmentos de código están diseñados para ejecutar funciones claras y específicas. 

    \item \textbf{Generación de Copias con Modificaciones}: Para cada archivo original, se generó una copia modificada siguiendo varias estrategias de variación:
    \begin{itemize}
        \item \textit{Renombramiento de Clases, Métodos y Variables}: Los nombres de clases, métodos y variables fueron modificados en las copias para simular diferencias en nomenclatura sin cambiar el objetivo funcional del código.
        \item \textit{Modificación de Estructura de Código}: Se alteraron estructuras sintácticas, como el tipo de bucles (de \texttt{for} a \texttt{while}) o la reestructuración de condiciones lógicas. Estas modificaciones permiten que la copia mantenga la misma funcionalidad que el original, pero con una apariencia diferente en términos de código.
        \item \textit{Ajustes en la Organización}: Algunos fragmentos fueron reorganizados en cuanto al orden de ejecución o el uso de estructuras de control alternativas, manteniendo los resultados finales consistentes con el código original.
    \end{itemize}
\end{enumerate}

\section{Dataset de diferencias}

Para maximizar la cantidad de datos disponibles y reflejar de manera efectiva la similitud entre proyectos, se creó un dataset que contiene todos los pares posibles (2 a 2) de proyectos del conjunto de datos original. En este proceso, para cada par de proyectos, se calcula y almacena la diferencia entre sus vectores correspondientes.\\

Este enfoque tiene varias ventajas significativas:

\begin{itemize}
	\item {\bf Incremento en la Cantidad de Datos:} Generar todos los pares posibles de proyectos incrementa exponencialmente el número de instancias en el dataset, proporcionando una base de datos más rica y diversa para entrenar modelos de aprendizaje automático.
	
	\item {\bf Etiquetado Automático de Datos:} Una ventaja de calcular la distancia entre los datos es que permite disponer de algunos datos etiquetados. Aunque no se puede afirmar si un proyecto individual es original o una copia de otro proyecto, al calcular las distancias dos a dos, se puede asegurar que un par de proyectos provenientes de diferentes tipos de proyectos no son copias uno del otro. Esto proporciona etiquetas adicionales que mejoran la calidad del entrenamiento del modelo.

	\item {\bf Captura de Relaciones Detalladas:} Al almacenar la diferencia entre los vectores de cada par de proyectos, se capturan las distancias y relaciones específicas entre todos los proyectos. Esto permite que el modelo de machine learning pueda aprender las sutilezas de las similitudes y diferencias entre distintos proyectos.
	
	\item {\bf Mejora en la Precisión del Modelo:} Con un mayor volumen de datos y la inclusión de las distancias entre pares, se espera que el modelo tenga un mejor desempeño en la tarea de detección de similitudes. La precisión del modelo se ve beneficiada al disponer de más ejemplos que reflejan una amplia gama de variaciones y similitudes.
	
	\item {\bf Refinamiento de las Métricas de Similitud:} Este método permite que se utilicen métricas de similitud precisas, ya que cada par de proyectos se compara de manera detallada. 

\end{itemize}

En resumen, la creación de este dataset con todos los pares posibles y sus diferencias vectoriales no solo aumenta la cantidad de datos disponibles, sino que también enriquece la información sobre las relaciones entre proyectos, mejorando así la capacidad del modelo para detectar similitudes de manera precisa y eficiente.  


\section{Word2Vec}

En el contexto del análisis de similitud de código, los nombres de variables, métodos y otros identificadores en el código fuente proporcionan información semántica sobre la funcionalidad y el propósito de diferentes partes del código. Por ejemplo, los identificadores que se usan de manera similar en diferentes contextos tendrán embeddings\footnote{Los embeddings son una técnica de procesamiento de lenguaje natural que convierte el lenguaje humano en vectores matemáticos. Estos vectores son una representación del significado subyacente de las palabras, lo que permite que las computadoras procesen el lenguaje de manera más efectiva.} similares. Sin embargo, los identificadores en el código no están estructurados de manera que las máquinas puedan comprender fácilmente sus relaciones semánticas, para esto se utilizó Word2Vec. El proceso involucró los siguientes pasos:

\begin{enumerate}
	\item \textit{Extracción de Identificadores}: Se extrajeron todos los nombres de variables, métodos, clases, interfaces, enumeraciones y delegados del código fuente utilizando la clase FeatureExtractorListener.
	
	\item \textit{Entrenamiento de Word2Vec}: Se utilizó un corpus de identificadores extraídos de múltiples proyectos de C\# para entrenar el modelo Word2Vec. El modelo aprendió las relaciones semánticas entre los diferentes identificadores en el contexto del código.
	
	\item \textit{Conversión a Embeddings}: Cada identificador extraído se convirtió en un vector de características numéricas utilizando el modelo Word2Vec entrenado. Luego se halla el promedio entre todos los vectores por feature correspondiente para asegurar que todos las caracteristicas de vectores tengan la misma dimensión. Estos vectores capturan la semántica y el contexto de los identificadores en el código.
	 
\end{enumerate}


\chapter{Redes Neuronales Siamesas para la Similitud de Código}\label{chapter:proposal}

Las redes neuronales siamesas se emplearon para analizar y capturar tanto la estructura como el comportamiento lógico del código. Este enfoque facilita la identificación de patrones y relaciones que trascienden las comparaciones textuales o sintácticas, proporcionando una mayor precisión en los resultados obtenidos. En este capítulo se detallan los componentes esenciales de esta arquitectura y el proceso llevado a cabo para su entrenamiento.


\section{Estructura de la Red Neuronal Siamesa}

La red neuronal siamesa utilizada está compuesta por dos subredes idénticas que comparten parámetros y pesos, una propiedad que garantiza que ambas subredes procesen las entradas de manera uniforme. Cada subred recibe como entrada un vector de características derivado del Árbol de Sintaxis Abstracta (AST) del código fuente, transformado previamente en una representación numérica adecuada para su procesamiento mediante redes neuronales. Este enfoque permite abstraer detalles superficiales del código, como nombres de variables o cambios en el formato, enfocándose en aspectos estructurales y funcionales que capturan la lógica del programa.

La arquitectura base de cada subred incluye capas de convolución unidimensional (Conv1D), las cuales son  utilizadas para capturar patrones locales en secuencias de datos. Estas capas están diseñadas para procesar vectores de entrada de forma eficiente y extraer características significativas mediante la convolución, seguida de operaciones de *pooling* que reducen la dimensionalidad y retienen las características más relevantes. La estructura general de la subred se describe como sigue:

\begin{itemize}
    \item Una capa de \textit{Conv1D} con 16 filtros y un tamaño de kernel de 8, activada mediante ReLU, seguida de una operación de \textit{max pooling} con un tamaño de ventana de 2.
    \item Una segunda capa de \textit{Conv1D} con 32 filtros y un tamaño de kernel de 4, también activada mediante ReLU, seguida de \textit{max pooling}.
    \item Una capa de \textit{Flatten} que transforma los tensores resultantes en un vector de características de alta dimensión.
    \item Tres capas densas, con 512, 256 y 10 neuronas respectivamente, utilizando ReLU para las dos primeras y softmax para la última. Esta última capa proyecta las características en un espacio de 10 dimensiones.
\end{itemize}

La salida de cada subred es un vector de alta dimensión \( \mathbf{h} \in \mathbb{R}^d \), donde \( d \) es el número de neuronas en la capa de salida. Estos vectores encapsulan las propiedades semánticas y estructurales del código procesado.

La comparación entre las dos salidas se realiza mediante una función de distancia. En este caso, se emplea la distancia euclidiana, definida como:

\[
d(\mathbf{h}_a, \mathbf{h}_b) = \sqrt{\sum_{i=1}^{d} (\mathbf{h}_{a,i} - \mathbf{h}_{b,i})^2},
\]

donde \( \mathbf{h}_a \) y \( \mathbf{h}_b \) son las representaciones vectoriales generadas por las dos subredes para los fragmentos de código \( a \) y \( b \). Esta métrica cuantifica el grado de similitud entre los fragmentos, donde distancias menores indican mayor similitud.

\section{Proceso de Entrenamiento y Función de Pérdida}

El modelo fue entrenado utilizando la \textit{pérdida de contraste} (contrastive loss), una función utilizada en redes siamesas para tareas de comparación y similitud. Esta función busca minimizar la distancia entre vectores de fragmentos de código similares y maximizarla para fragmentos disímiles. La pérdida de contraste se define como:

\[
L(y, d) = y \cdot d^2 + (1 - y) \cdot \max(0, m - d)^2,
\]

donde:
\begin{itemize}
    \item \( y \in \{0, 1\} \) es la etiqueta que indica si el par de fragmentos de código es similar (\( y = 1 \)) o disímil (\( y = 0 \)).
    \item \( d \) es la distancia euclidiana entre los vectores de los fragmentos generados por las subredes.
    \item \( m > 0 \) es un margen que define la distancia mínima esperada entre fragmentos disímiles.
\end{itemize}

El término \( y \cdot d^2 \) penaliza pares similares que están demasiado separados en el espacio vectorial, mientras que \( (1 - y) \cdot \max(0, m - d)^2 \) penaliza pares disímiles cuya distancia es menor que el margen \( m \). Esta formulación garantiza que los pares similares se agrupen en el espacio vectorial, mientras que los disímiles se alejen al menos una distancia \( m \).\\

El modelo fue optimizado mediante el optimizador Adam, conocido por su capacidad para manejar problemas de optimización no convexa en redes profundas. El aprendizaje se realizó durante 20 épocas con un tamaño de lote de 128, ajustando la tasa de aprendizaje inicial a 0.001. Durante el entrenamiento, se evaluó la pérdida en cada lote para garantizar la convergencia del modelo.\\

La arquitectura propuesta combina convoluciones unidimensionales y capas densas para extraer características relevantes de los fragmentos de código, aprovechando la estructura del AST como entrada. La función de pérdida de contraste, junto con la métrica de distancia euclidiana, permitió entrenar un modelo robusto capaz de identificar similitudes estructurales y funcionales. Este enfoque demuestra cómo las redes siamesas pueden superar las limitaciones de métodos tradicionales al enfocarse en aspectos semánticos y contextuales del código.

\section{Version2}

\subsection{Estructura y Proceso de Entrenamiento de la Red Neuronal Siamesa} 

Esta implementación de la red neuronal siamesa está diseñada para comparar fragmentos de código mediante la métrica de distancia \( L1 \), que calcula la diferencia absoluta entre las representaciones vectoriales generadas para cada fragmento. La arquitectura de la red se basa en una clase personalizada, `SiameseNeuralNetwork`, que encapsula la construcción, entrenamiento y predicción del modelo, proporcionando una solución modular y reutilizable para tareas de análisis de similitud de código.

\subsection{Arquitectura de la Red} 

La red neuronal consta de dos subredes idénticas que procesan los vectores de características extraídos de los fragmentos de código. Cada subred incluye las siguientes capas principales:

\begin{enumerate}
    \item \textbf{Preprocesamiento de la entrada:} La entrada, un vector de 65 dimensiones, se ajusta a una forma compatible con las operaciones de convolución unidimensional mediante una capa de \textit{Reshape}.
    \item \textbf{Capas de convolución unidimensional (Conv1D):} Se emplean dos capas convolucionales con tamaños de kernel de 8 y 4, y activación ReLU. Estas capas extraen patrones locales de las características del código.
    \item \textbf{Operaciones de Max Pooling:} Cada capa de convolución es seguida por una operación de \textit{max pooling} con un tamaño de ventana de 2, lo que reduce dimensionalidad mientras se preservan características relevantes.
    \item \textbf{Capas densas con regularización \( L2 \):} La salida convolucional se aplana y pasa por tres capas densas con activaciones ReLU y softmax. Estas capas incluyen regularización \( L2 \) para prevenir el sobreajuste y mejorar la generalización.
\end{enumerate}

La salida de cada subred es un vector de alta dimensión \( \mathbf{h} \in \mathbb{R}^d \) que encapsula las propiedades semánticas y estructurales del código.

\subsection{ Métrica de Distancia \( L1 \)}

La comparación entre los fragmentos de código se realiza mediante una capa de distancia \( L1 \), definida como:

\[
d_{L1}(\mathbf{h}_1, \mathbf{h}_2) = \sum_{i=1}^{d} |\mathbf{h}_{1,i} - \mathbf{h}_{2,i}|,
\]

donde \( \mathbf{h}_1 \) y \( \mathbf{h}_2 \) son los vectores generados por las subredes para cada fragmento de código. Esta distancia captura diferencias absolutas, permitiendo una medida robusta y sencilla de similitud.

\subsection{Proceso de Entrenamiento} 

El entrenamiento se realiza mediante la función de pérdida de entropía cruzada binaria, que se utiliza para clasificar pares de código como similares o disímiles. La función de pérdida se define como:

\[
L(y, \hat{y}) = -\frac{1}{N} \sum_{i=1}^{N} \left[ y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right],
\]

donde:
- \( y_i \) es la etiqueta verdadera (1 para pares similares, 0 para disímiles).
- \( \hat{y}_i \) es la probabilidad predicha por la red.
- \( N \) es el tamaño del lote.

Se utiliza el optimizador Adam con una tasa de aprendizaje inicial de 0.001, lo que garantiza una convergencia eficiente al encontrar mínimos locales en el espacio de pérdida.

El modelo se entrena durante 20 épocas, con un tamaño de lote de 32, y se evalúa utilizando un conjunto de validación que representa el 20\% de los datos originales. Este enfoque garantiza que la red aprenda a diferenciar fragmentos de código similares y disímiles mientras mantiene la capacidad de generalizar a nuevos datos.

\subsection{Predicción de Similitud} 

La red predice la similitud entre dos fragmentos de código generando un valor entre 0 y 1 mediante una capa densa con activación sigmoide. Un valor cercano a 1 indica alta similitud, mientras que valores cercanos a 0 reflejan una mayor diferencia. El proceso de predicción incluye los siguientes pasos:
\begin{enumerate}
    \item Los vectores de características de ambos fragmentos de código se pasan a las subredes.
    \item Se calcula la distancia \( L1 \) entre las salidas de las subredes.
    \item La capa sigmoide produce la probabilidad final de similitud.
\end{enumerate}



Esta implementación presenta un diseño modular y robusto que combina convoluciones unidimensionales, regularización \( L2 \), y la métrica de distancia \( L1 \) para abordar el problema de similitud de código. Además, el uso de la entropía cruzada binaria como función de pérdida asegura que la red optimice de manera efectiva su capacidad para distinguir entre fragmentos de código similares y disímiles. Esta arquitectura es particularmente adecuada para aplicaciones donde los datos presentan patrones estructurales complejos que requieren una evaluación precisa y escalable. 
